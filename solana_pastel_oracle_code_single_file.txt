./README.md
---
# Solana-Pastel Oracle Program

## Overview
This program serves as an oracle service, creating a bridge between the Solana blockchain and the Pastel Network. It focuses on verifying and monitoring Pastel transaction IDs (TXIDs) and related blockchain tickets, as well as the files associated with these tickets.

## Functionality
- **Transaction Monitoring**: Tracks Pastel TXIDs, updating their status (e.g., pending, mined) within the Solana blockchain.
- **Data Compliance and Reward System**: Implements a system for contributors to submit reports on Pastel TXID statuses, with rewards based on report accuracy and reliability.
- **Consensus Algorithm**: Uses a consensus mechanism to ascertain the most accurate status of Pastel TXIDs, based on multiple oracle reports.
- **Ban Mechanism**: Features temporary and permanent bans for contributors based on non-consensus report submissions.

## Core Components
- **OracleContractState**: Maintains the central state of the oracle, including contributor data, consensus data, and TXID submission counts.
- **Contributor Management**: Registers new data contributors and manages their compliance and reliability scores. Contributors must meet certain criteria to be eligible for rewards.
- **Report Submission and Processing**: Manages the submission of Pastel TXID status reports by contributors and processes these reports to update consensus data and contributor scores.
- **Consensus Calculation**: Determines the consensus on TXID status based on aggregated data from multiple reports.
- **Reward and Penalty Mechanisms**: Manages rewards distribution to contributors and applies ban penalties in case of report inconsistencies.
- **Fee and Payment Management**: Handles the addition of new Pastel TXIDs for monitoring, including payment processing for such additions.

## Key Constants and Variables
- **Registration and Reward Fees**: Specifies the fees for contributor registration and the base reward amount for report submissions.
- **Ban Thresholds**: Defines the thresholds for temporary and permanent bans based on report submission accuracy.
- **Consensus Parameters**: Establishes the minimum requirements for consensus calculation among oracle reports.

## Security and Validation
- Ensures data integrity through rigorous checks at every step, from contributor registration to report submission and consensus calculation.
- Implements a robust validation mechanism to prevent incorrect or fraudulent data submissions.

## Setup Instructions

### Install Solana Testnet on Ubuntu

#### Install Rustup
```bash
curl https://sh.rustup.rs -sSf | sh
rustup default nightly  
rustup update nightly   
rustc --version 
```

#### Install Solana
```bash
sudo apt update && sudo apt upgrade -y && sudo apt autoremove -y  
sudo apt install libssl-dev libudev-dev pkg-config zlib1g-dev llvm clang make -y         
sh -c "$(curl -sSfL https://release.solana.com/v1.18.15/install)"      
export PATH="/home/ubuntu/.local/share/solana/install/active_release/bin:$PATH" 
source ~/.zshrc   # If you use Zsh
solana --version  
```

### Setup Anchor

```bash
sudo apt-get update && sudo apt-get upgrade && sudo apt-get install -y pkg-config build-essential libudev-dev
cargo install --git https://github.com/coral-xyz/anchor avm --locked --force
avm install latest
avm use latest
anchor --version
```

### Get Code and Test

```bash
git clone https://github.com/pastelnetwork/solana_pastel_oracle_program.git
cd solana_pastel_oracle_program
anchor test
```

These steps will set up the necessary environment for running the Solana-Pastel Oracle Program, including the installation of Rust, Solana, and Anchor, as well as cloning the repository and running tests to ensure everything is correctly set up.


## Testing Code

The testing code for the Solana-Pastel Oracle Program, written in TypeScript using the Anchor framework, performs comprehensive tests to validate the functionality of the program. It uses Mocha for structuring tests and Chai for assertions. Here's an overview of its components and functionalities:

1. **Setup and Configuration**: 
    - Initializes Anchor with the Solana testnet and sets various configurations.
    - Defines constants and variables such as program ID, contributor details, TXID counts, and error codes.

2. **Initialization Tests**: 
    - Tests the initialization and expansion of the oracle contract state.
    - Uses PDAs (Program-Derived Addresses) for various accounts like reward pool, fee-receiving contract, and contributor data.
    - Confirms the contract state's initialization and checks the reallocation of the oracle state.

3. **Set Bridge Contract Tests**: 
    - Ensures the bridge contract address is correctly set to the admin address.

4. **Contributor Registration Tests**: 
    - Registers new data contributors and validates their registration.
    - Transfers the registration fee to the required accounts and confirms the contributor's registration in the system.

5. **TXID Monitoring Tests**: 
    - Adds multiple TXIDs for monitoring and checks if they are correctly monitored.
    - Verifies the creation of corresponding `PendingPayment` structs for each TXID.

6. **Data Report Submission Tests**: 
    - Submits data reports for different TXIDs to simulate both consensus and dissent among contributors.
    - Determines the status of TXIDs (e.g., MinedActivated, Invalid) and submits reports accordingly.
    - Validates the consensus on TXID status after the reports are submitted.

7. **Data Cleanup Verification Tests**: 
    - Ensures that data related to TXIDs is properly cleaned up from the `TempTxStatusReportAccount` after consensus is reached.

8. **Payment Processing Tests**: 
    - Simulates the processing of payments for monitored TXIDs by the bridge contract.
    - Transfers payments and confirms that the payments are correctly recorded in the system.

9. **Eligibility for Rewards Tests**: 
    - Checks if contributors meet the eligibility criteria for rewards based on compliance, reliability scores, and report submissions.

10. **Reward Distribution Tests**: 
    - Tests the distribution of rewards from the reward pool to eligible contributors.
    - Verifies that ineligible contributors cannot request rewards.

Throughout these tests, the code interacts with various accounts and PDAs, simulating real-world scenarios of contributor activities and interactions with the oracle contract. The tests cover various aspects of the program, including state initialization, contributor management, transaction monitoring, consensus mechanism, and reward distribution, ensuring the program functions as intended.

## Consensus Process and Contributor Scoring System

### Consensus Process

The consensus process in the Solana-Pastel Oracle Program is designed to determine the most reliable status of a Pastel transaction ID (TXID) based on reports from multiple contributors. Here's how it works:

1. **Aggregating Data**: The `get_aggregated_data` function retrieves the aggregated consensus data for a given TXID, which includes the weighted status and hash values reported by contributors.

2. **Computing Consensus**: The `compute_consensus` function calculates the consensus status and hash for the TXID. It identifies the status and hash with the highest accumulated weight as the consensus outcome.

3. **Consensus Decision**: The consensus status represents the most agreed-upon state of the TXID, and the consensus hash represents the most agreed-upon hash of the corresponding file.

### Rationale Behind the Consensus Design

- **Robustness**: Using a weighted approach where each contributor's report influences the consensus based on their reliability and compliance score ensures robustness against inaccurate or malicious reports.
- **Flexibility**: The mechanism can adapt to different scenarios, like new information or changing network conditions, by recalculating the consensus with each new report.

### Contributor Scoring System

The scoring system for contributors is a crucial aspect of the program, affecting their influence in the consensus process and their eligibility for rewards.

#### Score Adjustment Mechanisms

1. **Updating Scores (`update_scores`)**: Contributors’ scores are dynamically adjusted based on their report accuracy. Accurate reports increase their compliance and reliability scores, while inaccurate reports lead to a decrease.

2. **Applying Bans (`apply_bans`)**: Contributors with a pattern of inaccurate reporting are subject to temporary or permanent bans, reducing the risk of bad actors influencing the consensus process.

3. **Time-Based Decay**: The system implements a decay factor on scores over time, encouraging continuous and consistent participation.

#### Rationale Behind Scoring Components

- **Accuracy and Streaks**: Rewarding accuracy and consistency (streaks) incentivizes contributors to provide reliable data. The scaling bonus for consecutive accurate reports encourages sustained high-quality participation.
  
- **Time Weight**: The time since the last active contribution is factored into score adjustments. This ensures that active contributors have a more significant impact on the consensus and rewards.

- **Decay Mechanism**: To maintain a dynamic and responsive system, scores decay over time. This prevents long-inactive contributors from retaining high influence and encourages regular participation.

- **Reliability Integration**: A contributor’s overall reliability (ratio of accurate reports to total reports) is integrated into their compliance score, ensuring that consistently reliable contributors have more influence.

#### Purpose of the Scoring System

- **Quality Control**: Ensures that the data influencing the consensus process is of high quality and from reliable sources.
- **Incentive Alignment**: Aligns contributors' incentives with the network's goal of accurate and reliable data reporting.
- **Adaptability**: Allows the system to adapt to changing participant behaviors and network conditions by recalibrating contributor influence dynamically.
- **Security**: Protects against manipulation or attacks by devaluing the influence of malicious or consistently inaccurate contributors.


## Step-by-Step Narrative of How the System Works:

### 1. Initialization

**Objective**: Set up the initial state of the oracle contract, including various PDAs and admin public key.

#### Initialize Program:

1. **Function Definition**:
   - The `initialize` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<Initialize>` and an `admin_pubkey: Pubkey` as parameters.

2. **Oracle Contract State Setup**:
   - Inside the `initialize` function, the `initialize_oracle_state` method is called on the `ctx.accounts`.
   - This method checks if the oracle contract state is already initialized. If it is, an `OracleError::AccountAlreadyInitialized` error is returned.
   - The `is_initialized` flag is set to `true`, and the `admin_pubkey` is assigned to the `admin_pubkey` field of the oracle contract state.
   - The `monitored_txids` vector is initialized as an empty vector.
   - The `bridge_contract_pubkey` is set to the default public key.

3. **PDA Initialization**:
   - Several accounts are initialized using PDAs (Program Derived Accounts):
     - `RewardPool` and `FeeReceivingContract` accounts are initialized with seeds "reward_pool" and "fee_receiving_contract", respectively.
     - `TempTxStatusReportAccount` is initialized with the seed "temp_tx_status_report".
     - `ContributorDataAccount` is initialized with the seed "contributor_data".
     - `TxidSubmissionCountsAccount` is initialized with the seed "txid_submission_counts".
     - `AggregatedConsensusDataAccount` is initialized with the seed "aggregated_consensus_data".
   - These accounts are allocated with a specific amount of space (e.g., 10,240 bytes) to store relevant data.

4. **Logging**:
   - Messages are logged to indicate successful initialization and the public keys of the various accounts.

### 2. Contributor Registration

**Objective**: Allow new contributors to register and start participating in data submission.

#### Register New Contributors:

1. **Function Definition**:
   - The `register_new_data_contributor` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<RegisterNewDataContributor>` as a parameter.

2. **Check for Existing Registration**:
   - Inside the `register_new_data_contributor_helper` function, the program first checks if the contributor is already registered by iterating through the `contributors` vector in the `ContributorDataAccount`.
   - If the contributor's public key already exists, an `OracleError::ContributorAlreadyRegistered` error is returned.

3. **Verify Registration Fee**:
   - The program verifies that the registration fee has been paid by checking the lamports in the `fee_receiving_contract_account`.
   - If the fee is not present, an `OracleError::RegistrationFeeNotPaid` error is returned.

4. **Transfer Registration Fee**:
   - The registration fee is deducted from the `fee_receiving_contract_account` and added to the `reward_pool_account`.

5. **Initialize Contributor Data**:
   - A new `Contributor` struct is created with initial values:
     - `reward_address`: Contributor's public key.
     - `registration_entrance_fee_transaction_signature`: Initially empty string.
     - `compliance_score`: Set to 1.0.
     - `last_active_timestamp`: Set to the current Unix timestamp.
     - `total_reports_submitted`: Initially 0.
     - `accurate_reports_count`: Initially 0.
     - `current_streak`: Initially 0.
     - `reliability_score`: Set to 1.0.
     - `consensus_failures`: Initially 0.
     - `ban_expiry`: Initially 0.
     - `is_eligible_for_rewards`: Initially false.
     - `is_recently_active`: Initially false.
     - `is_reliable`: Initially false.
   - This new contributor is then appended to the `contributors` vector in the `ContributorDataAccount`.

6. **Logging**:
   - Messages are logged to indicate successful registration and the contributor's public key and registration timestamp.

### 3. TXID Monitoring

**Objective**: Add TXIDs to be monitored by the oracle and track them.

#### Add TXID for Monitoring:

1. **Function Definition**:
   - The `add_txid_for_monitoring` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<AddTxidForMonitoring>` and an `AddTxidForMonitoringData` as parameters.

2. **Parameter Validation**:
   - Inside the `add_txid_for_monitoring_helper` function, the `data.txid` parameter is validated to ensure it does not exceed the maximum length (`MAX_TXID_LENGTH`). If it does, an `OracleError::InvalidTxid` error is returned.

3. **Verify Caller**:
   - The program checks that the caller's public key matches the `bridge_contract_pubkey` in the Oracle Contract State. If not, an `OracleError::NotBridgeContractAddress` error is returned. This ensures only authorized entities can add TXIDs for monitoring.

4. **Add TXID to Monitored List**:
   - The TXID is added to the `monitored_txids` vector in the Oracle Contract State. This vector keeps track of all TXIDs currently being monitored by the oracle.

5. **Initialize Pending Payment Account**:
   - A pending payment account is initialized for the TXID using the `HandlePendingPayment` context.
   - The pending payment account is initialized with the expected amount for monitoring (`COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING`) and the payment status is set to `Pending`.

6. **Logging**:
   - Messages are logged to indicate the successful addition of the TXID for monitoring and the initialization of the pending payment account.

### 4. Data Report Submission

**Objective**: Collect and validate data reports from contributors for the monitored TXIDs.

#### Submit Data Report:

1. **Function Definition**:
   - The `submit_data_report` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<SubmitDataReport>`, `txid: String`, `txid_status_str: String`, `pastel_ticket_type_str: String`, `first_6_characters_hash: String`, and `contributor_reward_address: Pubkey` as parameters.

2. **Report Creation**:
   - Inside the `submit_data_report_helper` function, the parameters are used to create a `PastelTxStatusReport` struct.
   - The `txid_status_str` is converted to the `TxidStatus` enum, and the `pastel_ticket_type_str` is converted to the `PastelTicketType` enum.
   - The current Unix timestamp is fetched and included in the report.

3. **Validation**:
   - The `validate_data_contributor_report` function is called to validate the report.
   - It ensures the TXID is not empty, the TXID status and pastel ticket type are valid, and the file hash is the correct length and contains only hex characters. If any of these validations fail, appropriate errors (e.g., `OracleError::InvalidTxid`, `OracleError::InvalidTxidStatus`, `OracleError::InvalidFileHashLength`, `OracleError::MissingFileHash`) are returned.

4. **Contributor Verification**:
   - The program checks if the contributor is registered and not banned. If the contributor's public key is not found in the `ContributorDataAccount`, an `OracleError::ContributorNotRegistered` error is returned.
   - The `calculate_is_banned` method on the `Contributor` struct is called to determine if the contributor is currently banned. If so, an `OracleError::ContributorBanned` error is returned.

5. **Common and Specific Report Data**:
   - Common report data (`CommonReportData`) is extracted from the report and either found or added to the `TempTxStatusReportAccount`.
   - Specific report data (`SpecificReportData`) is created with the contributor's reward address, timestamp, and a reference to the common data.

6. **Temporary Report Entry**:
   - A temporary report (`TempTxStatusReport`) is created with the common data reference and specific data.
   - This temporary report is added to the `TempTxStatusReportAccount`.

7. **Update Submission Count**:
   - The `update_submission_count` function is called to update the submission count for the TXID in the `TxidSubmissionCountsAccount`.

8. **Aggregate Consensus Data**:
   - The `aggregate_consensus_data` function is called to update the consensus data based on the submitted report. The contributor's compliance and reliability scores are used to weight the report.

9. **Consensus Calculation Check**:
   - The `should_calculate_consensus` function is called to determine if enough reports have been submitted to calculate consensus. If so, the `calculate_consensus` function is called to compute the consensus and update contributor scores.

10. **Logging**:
    - Messages are logged to indicate successful report submission, updated submission counts, and consensus calculation if triggered.

### 5. Consensus Calculation

**Objective**: Reach a consensus on the status and hash of each TXID based on the submitted reports.

#### Update Submission Count:

1. **Function Definition**:
   - The `update_submission_count` function is responsible for updating the submission count for a TXID.
   - It takes the `txid_submission_counts_account` and `txid` as parameters.

2. **Timestamp Retrieval**:
   - The current Unix timestamp is fetched using `Clock::get()?.unix_timestamp as u64`.

3. **Check for Existing TXID**:
   - The function checks if the TXID already exists in the submission counts.
   - If it does, the existing count is incremented, and the `last_updated` timestamp is updated.
   - If the TXID does not exist, a new `TxidSubmissionCount` entry is created with an initial count of 1 and the current timestamp.

4. **Return**:
   - The function returns `Ok(())` after updating the submission count.

#### Compute Consensus:

1. **Function Definition**:
   - The `compute_consensus` function is responsible for determining the consensus status and hash for a TXID.
   - It takes `aggregated_data` as a parameter.

2. **Status Aggregation**:
   - The function iterates over the `status_weights` array in `aggregated_data`.
   - It selects the status with the highest weight (i.e., the status reported by the most contributors) as the consensus status.

3. **Hash Aggregation**:
   - The function iterates over the `hash_weights` vector in `aggregated_data`.
   - It selects the hash with the highest weight as the consensus hash.

4. **Return**:
   - The function returns a tuple containing the consensus status and hash.

#### Update Contributor Scores:

1. **Function Definition**:
   - The `update_contributor` function is responsible for updating a contributor's compliance and reliability scores based on the accuracy of their reports.
   - It takes a mutable reference to a `Contributor`, the current timestamp, and a boolean indicating whether the report was accurate.

2. **Score Updates**:
   - If the report is accurate:
     - The contributor's `total_reports_submitted` and `accurate_reports_count` are incremented.
     - The contributor's `current_streak` is incremented.
     - The compliance score is increased based on dynamic scaling and time weight.
   - If the report is inaccurate:
     - The contributor's `total_reports_submitted` is incremented.
     - The `current_streak` is reset to 0.
     - The `consensus_failures` count is incremented.
     - The compliance score is decreased based on a penalty.

3. **Decay and Reliability Factor**:
   - The compliance score is decayed over time.
   - The reliability score is calculated based on the ratio of accurate reports to total reports.
   - The compliance score is scaled based on the reliability factor and logistic scaling.

4. **Log Scores**:
   - The updated scores are logged for debugging purposes.

#### Post-Consensus Cleanup:

1. **Function Definition**:
   - The `post_consensus_tasks` function is responsible for cleaning up old or unnecessary data after consensus is reached.
   - It takes references to `txid_submission_counts_account`, `aggregated_data_account`, `temp_report_account`, `contributor_data_account`, and the `txid`.

2. **Apply Permanent Bans**:
   - The `apply_permanent_bans` function removes contributors who have been permanently banned from the `ContributorDataAccount`.

3. **Cleanup Temporary Reports**:
   - The function retains only the temporary reports that do not match the `txid` and are within the `DATA_RETENTION_PERIOD`.

4. **Cleanup Aggregated Consensus Data**:
   - The function retains only the consensus data that is within the `DATA_RETENTION_PERIOD`.

5. **Cleanup Submission Counts**:
   - The function retains only the submission counts that are within the `SUBMISSION_COUNT_RETENTION_PERIOD`.

6. **Logging**:
   - Messages are logged to indicate the completion of cleanup tasks.

### 6. Payment Processing

**Objective**: Process payments for monitoring TXIDs and update payment status.

#### Process Payment:

1. **Function Definition**:
   - The `process_payment` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<ProcessPayment>`, `txid: String`, and `amount: u64` as parameters.

2. **Context Definition**:
   - The `ProcessPayment` context defines the accounts involved in the payment process.
   - This includes the source account, oracle contract state, and pending payment account.

3. **Function Execution**:
   - The `process_payment_helper` function is called within `process_payment` to handle the payment logic.
   - The function takes the context, TXID, and payment amount as parameters.

4. **Pending Payment Account Validation**:
   - The function first checks that the `pending_payment_account` corresponds to the provided TXID.
   - If the TXID in the `pending_payment_account` does not match the provided TXID, an error `OracleError::PaymentNotFound` is returned.

5. **Payment Amount Validation**:
   - The function ensures that the payment amount matches the expected amount in the `pending_payment_account`.
   - If the payment amount does not match, an error `OracleError::InvalidPaymentAmount` is returned.

6. **Update Payment Status**:
   - Once the payment is validated, the payment status in the `pending_payment_account` is updated to `Received`.
   - This indicates that the expected payment amount has been successfully received.

7. **Logging**:
   - Throughout the process, various log messages (`msg!`) are used to track the progress and any issues encountered.
   - This includes logging when the payment is successfully processed and if there are any validation errors.

### 7. Reward Distribution

**Objective**: Distribute rewards to eligible contributors based on their compliance and reliability scores.

#### Request Reward:

1. **Function Definition**:
   - The `request_reward` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<RequestReward>` and a `contributor_address: Pubkey` as parameters.

2. **Context Definition**:
   - The `RequestReward` context defines the accounts involved in the reward distribution process.
   - This includes the reward pool account, the oracle contract state, the contributor data account, and the contributor’s account.

3. **Function Execution**:
   - The `request_reward_helper` function is called with the context and contributor's public key.

4. **Contributor Validation**:
   - The function first finds the contributor in the `ContributorDataAccount` using the provided public key.
   - If the contributor is not found, an error `OracleError::UnregisteredOracle` is returned.

5. **Eligibility Check**:
   - The function checks if the contributor meets the eligibility criteria, which include:
     - A minimum number of reports submitted.
     - Compliance score above `MIN_COMPLIANCE_SCORE_FOR_REWARD`.
     - Reliability score above `MIN_RELIABILITY_SCORE_FOR_REWARD`.
   - If the contributor is not eligible, an error `OracleError::NotEligibleForReward` is returned.

6. **Reward Amount Calculation**:
   - The reward amount is determined based on the `BASE_REWARD_AMOUNT_IN_LAMPORTS`.
   - This base amount can be scaled based on additional criteria if needed.

7. **Funds Availability Check**:
   - The function ensures that the reward pool account has sufficient funds to cover the reward amount.
   - If the reward pool has insufficient funds, an error `OracleError::InsufficientFunds` is returned.

8. **Transfer Reward**:
   - The function transfers the reward amount from the reward pool account to the contributor's account.
   - This involves decrementing the lamports in the reward pool account and incrementing the lamports in the contributor's account.

## Explanation of Typescript Testing Script

### Initialization

1. **Environment Setup**:
   - The program sets up environment variables for the Anchor provider URL and logging.
   - It initializes the Anchor provider and sets it as the default provider for the program.

2. **Program and Account Setup**:
   - The program ID and the oracle contract state account are defined.
   - Public Key Address (PDA) accounts for various purposes (e.g., reward pool, fee receiving contract, contributor data, TXID submission counts, and aggregated consensus data) are generated using `web3.PublicKey.findProgramAddressSync`.

3. **Funding the Oracle Contract State Account**:
   - The oracle contract state account is funded with enough SOL to cover the rent-exempt minimum balance required by the Solana network.

4. **Initialization and Reallocation**:
   - The program initializes the oracle contract state, setting up initial parameters and PDAs.
   - The contract state is expanded incrementally to accommodate additional data, up to a maximum size of 200KB.

### Contributor Registration

1. **Contributor Registration**:
   - Contributors are registered by generating new keypairs and paying a registration entrance fee.
   - The program transfers the registration fee to the fee receiving contract account PDA.
   - New contributors are added to the ContributorDataAccount PDA.

### TXID Monitoring

1. **Adding TXIDs for Monitoring**:
   - The program generates random TXIDs and adds them for monitoring.
   - Each TXID is associated with a pending payment account, which is initialized with the expected payment amount.
   - The TXID is then added to the monitored list in the oracle contract state.

2. **Verification of Monitored TXIDs**:
   - The program verifies that all monitored TXIDs have corresponding pending payment structs.
   - It checks the payment status and ensures the expected amount matches the defined cost.

### Data Report Submission

1. **Submitting Data Reports**:
   - Contributors submit data reports for the monitored TXIDs.
   - Reports include TXID status, pastel ticket type, and a random file hash.
   - The program handles both correct and incorrect submissions based on a predefined error probability.

2. **Consensus Data**:
   - The program aggregates consensus data for each TXID based on the submitted reports.
   - It determines the majority consensus status and logs the results.

### Payment Processing

1. **Processing Payments**:
   - The program processes payments for the monitored TXIDs by transferring the payment amount from the admin account to the fee-receiving contract PDA.
   - It updates the payment status to "Received" and verifies the changes.

### Reward Distribution

1. **Eligibility Check and Reward Distribution**:
   - The program checks if contributors meet the criteria for reward eligibility based on their compliance and reliability scores.
   - Eligible contributors receive rewards from the reward pool account PDA.
   - The program verifies that reward distribution is accurate and logs the changes in account balances.


---
./solana_pastel_oracle_code_single_file.txt
---
./README.md
---
# Solana-Pastel Oracle Program

## Overview
This program serves as an oracle service, creating a bridge between the Solana blockchain and the Pastel Network. It focuses on verifying and monitoring Pastel transaction IDs (TXIDs) and related blockchain tickets, as well as the files associated with these tickets.

## Functionality
- **Transaction Monitoring**: Tracks Pastel TXIDs, updating their status (e.g., pending, mined) within the Solana blockchain.
- **Data Compliance and Reward System**: Implements a system for contributors to submit reports on Pastel TXID statuses, with rewards based on report accuracy and reliability.
- **Consensus Algorithm**: Uses a consensus mechanism to ascertain the most accurate status of Pastel TXIDs, based on multiple oracle reports.
- **Ban Mechanism**: Features temporary and permanent bans for contributors based on non-consensus report submissions.

## Core Components
- **OracleContractState**: Maintains the central state of the oracle, including contributor data, consensus data, and TXID submission counts.
- **Contributor Management**: Registers new data contributors and manages their compliance and reliability scores. Contributors must meet certain criteria to be eligible for rewards.
- **Report Submission and Processing**: Manages the submission of Pastel TXID status reports by contributors and processes these reports to update consensus data and contributor scores.
- **Consensus Calculation**: Determines the consensus on TXID status based on aggregated data from multiple reports.
- **Reward and Penalty Mechanisms**: Manages rewards distribution to contributors and applies ban penalties in case of report inconsistencies.
- **Fee and Payment Management**: Handles the addition of new Pastel TXIDs for monitoring, including payment processing for such additions.

## Key Constants and Variables
- **Registration and Reward Fees**: Specifies the fees for contributor registration and the base reward amount for report submissions.
- **Ban Thresholds**: Defines the thresholds for temporary and permanent bans based on report submission accuracy.
- **Consensus Parameters**: Establishes the minimum requirements for consensus calculation among oracle reports.

## Security and Validation
- Ensures data integrity through rigorous checks at every step, from contributor registration to report submission and consensus calculation.
- Implements a robust validation mechanism to prevent incorrect or fraudulent data submissions.

## Setup Instructions

### Install Solana Testnet on Ubuntu

#### Install Rustup
```bash
curl https://sh.rustup.rs -sSf | sh
rustup default nightly  
rustup update nightly   
rustc --version 
```

#### Install Solana
```bash
sudo apt update && sudo apt upgrade -y && sudo apt autoremove -y  
sudo apt install libssl-dev libudev-dev pkg-config zlib1g-dev llvm clang make -y         
sh -c "$(curl -sSfL https://release.solana.com/v1.18.15/install)"      
export PATH="/home/ubuntu/.local/share/solana/install/active_release/bin:$PATH" 
source ~/.zshrc   # If you use Zsh
solana --version  
```

### Setup Anchor

```bash
sudo apt-get update && sudo apt-get upgrade && sudo apt-get install -y pkg-config build-essential libudev-dev
cargo install --git https://github.com/coral-xyz/anchor avm --locked --force
avm install latest
avm use latest
anchor --version
```

### Get Code and Test

```bash
git clone https://github.com/pastelnetwork/solana_pastel_oracle_program.git
cd solana_pastel_oracle_program
anchor test
```

These steps will set up the necessary environment for running the Solana-Pastel Oracle Program, including the installation of Rust, Solana, and Anchor, as well as cloning the repository and running tests to ensure everything is correctly set up.


## Testing Code

The testing code for the Solana-Pastel Oracle Program, written in TypeScript using the Anchor framework, performs comprehensive tests to validate the functionality of the program. It uses Mocha for structuring tests and Chai for assertions. Here's an overview of its components and functionalities:

1. **Setup and Configuration**: 
    - Initializes Anchor with the Solana testnet and sets various configurations.
    - Defines constants and variables such as program ID, contributor details, TXID counts, and error codes.

2. **Initialization Tests**: 
    - Tests the initialization and expansion of the oracle contract state.
    - Uses PDAs (Program-Derived Addresses) for various accounts like reward pool, fee-receiving contract, and contributor data.
    - Confirms the contract state's initialization and checks the reallocation of the oracle state.

3. **Set Bridge Contract Tests**: 
    - Ensures the bridge contract address is correctly set to the admin address.

4. **Contributor Registration Tests**: 
    - Registers new data contributors and validates their registration.
    - Transfers the registration fee to the required accounts and confirms the contributor's registration in the system.

5. **TXID Monitoring Tests**: 
    - Adds multiple TXIDs for monitoring and checks if they are correctly monitored.
    - Verifies the creation of corresponding `PendingPayment` structs for each TXID.

6. **Data Report Submission Tests**: 
    - Submits data reports for different TXIDs to simulate both consensus and dissent among contributors.
    - Determines the status of TXIDs (e.g., MinedActivated, Invalid) and submits reports accordingly.
    - Validates the consensus on TXID status after the reports are submitted.

7. **Data Cleanup Verification Tests**: 
    - Ensures that data related to TXIDs is properly cleaned up from the `TempTxStatusReportAccount` after consensus is reached.

8. **Payment Processing Tests**: 
    - Simulates the processing of payments for monitored TXIDs by the bridge contract.
    - Transfers payments and confirms that the payments are correctly recorded in the system.

9. **Eligibility for Rewards Tests**: 
    - Checks if contributors meet the eligibility criteria for rewards based on compliance, reliability scores, and report submissions.

10. **Reward Distribution Tests**: 
    - Tests the distribution of rewards from the reward pool to eligible contributors.
    - Verifies that ineligible contributors cannot request rewards.

Throughout these tests, the code interacts with various accounts and PDAs, simulating real-world scenarios of contributor activities and interactions with the oracle contract. The tests cover various aspects of the program, including state initialization, contributor management, transaction monitoring, consensus mechanism, and reward distribution, ensuring the program functions as intended.

## Consensus Process and Contributor Scoring System

### Consensus Process

The consensus process in the Solana-Pastel Oracle Program is designed to determine the most reliable status of a Pastel transaction ID (TXID) based on reports from multiple contributors. Here's how it works:

1. **Aggregating Data**: The `get_aggregated_data` function retrieves the aggregated consensus data for a given TXID, which includes the weighted status and hash values reported by contributors.

2. **Computing Consensus**: The `compute_consensus` function calculates the consensus status and hash for the TXID. It identifies the status and hash with the highest accumulated weight as the consensus outcome.

3. **Consensus Decision**: The consensus status represents the most agreed-upon state of the TXID, and the consensus hash represents the most agreed-upon hash of the corresponding file.

### Rationale Behind the Consensus Design

- **Robustness**: Using a weighted approach where each contributor's report influences the consensus based on their reliability and compliance score ensures robustness against inaccurate or malicious reports.
- **Flexibility**: The mechanism can adapt to different scenarios, like new information or changing network conditions, by recalculating the consensus with each new report.

### Contributor Scoring System

The scoring system for contributors is a crucial aspect of the program, affecting their influence in the consensus process and their eligibility for rewards.

#### Score Adjustment Mechanisms

1. **Updating Scores (`update_scores`)**: Contributors’ scores are dynamically adjusted based on their report accuracy. Accurate reports increase their compliance and reliability scores, while inaccurate reports lead to a decrease.

2. **Applying Bans (`apply_bans`)**: Contributors with a pattern of inaccurate reporting are subject to temporary or permanent bans, reducing the risk of bad actors influencing the consensus process.

3. **Time-Based Decay**: The system implements a decay factor on scores over time, encouraging continuous and consistent participation.

#### Rationale Behind Scoring Components

- **Accuracy and Streaks**: Rewarding accuracy and consistency (streaks) incentivizes contributors to provide reliable data. The scaling bonus for consecutive accurate reports encourages sustained high-quality participation.
  
- **Time Weight**: The time since the last active contribution is factored into score adjustments. This ensures that active contributors have a more significant impact on the consensus and rewards.

- **Decay Mechanism**: To maintain a dynamic and responsive system, scores decay over time. This prevents long-inactive contributors from retaining high influence and encourages regular participation.

- **Reliability Integration**: A contributor’s overall reliability (ratio of accurate reports to total reports) is integrated into their compliance score, ensuring that consistently reliable contributors have more influence.

#### Purpose of the Scoring System

- **Quality Control**: Ensures that the data influencing the consensus process is of high quality and from reliable sources.
- **Incentive Alignment**: Aligns contributors' incentives with the network's goal of accurate and reliable data reporting.
- **Adaptability**: Allows the system to adapt to changing participant behaviors and network conditions by recalibrating contributor influence dynamically.
- **Security**: Protects against manipulation or attacks by devaluing the influence of malicious or consistently inaccurate contributors.


## Step-by-Step Narrative of How the System Works:

### 1. Initialization

**Objective**: Set up the initial state of the oracle contract, including various PDAs and admin public key.

#### Initialize Program:

1. **Function Definition**:
   - The `initialize` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<Initialize>` and an `admin_pubkey: Pubkey` as parameters.

2. **Oracle Contract State Setup**:
   - Inside the `initialize` function, the `initialize_oracle_state` method is called on the `ctx.accounts`.
   - This method checks if the oracle contract state is already initialized. If it is, an `OracleError::AccountAlreadyInitialized` error is returned.
   - The `is_initialized` flag is set to `true`, and the `admin_pubkey` is assigned to the `admin_pubkey` field of the oracle contract state.
   - The `monitored_txids` vector is initialized as an empty vector.
   - The `bridge_contract_pubkey` is set to the default public key.

3. **PDA Initialization**:
   - Several accounts are initialized using PDAs (Program Derived Accounts):
     - `RewardPool` and `FeeReceivingContract` accounts are initialized with seeds "reward_pool" and "fee_receiving_contract", respectively.
     - `TempTxStatusReportAccount` is initialized with the seed "temp_tx_status_report".
     - `ContributorDataAccount` is initialized with the seed "contributor_data".
     - `TxidSubmissionCountsAccount` is initialized with the seed "txid_submission_counts".
     - `AggregatedConsensusDataAccount` is initialized with the seed "aggregated_consensus_data".
   - These accounts are allocated with a specific amount of space (e.g., 10,240 bytes) to store relevant data.

4. **Logging**:
   - Messages are logged to indicate successful initialization and the public keys of the various accounts.

### 2. Contributor Registration

**Objective**: Allow new contributors to register and start participating in data submission.

#### Register New Contributors:

1. **Function Definition**:
   - The `register_new_data_contributor` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<RegisterNewDataContributor>` as a parameter.

2. **Check for Existing Registration**:
   - Inside the `register_new_data_contributor_helper` function, the program first checks if the contributor is already registered by iterating through the `contributors` vector in the `ContributorDataAccount`.
   - If the contributor's public key already exists, an `OracleError::ContributorAlreadyRegistered` error is returned.

3. **Verify Registration Fee**:
   - The program verifies that the registration fee has been paid by checking the lamports in the `fee_receiving_contract_account`.
   - If the fee is not present, an `OracleError::RegistrationFeeNotPaid` error is returned.

4. **Transfer Registration Fee**:
   - The registration fee is deducted from the `fee_receiving_contract_account` and added to the `reward_pool_account`.

5. **Initialize Contributor Data**:
   - A new `Contributor` struct is created with initial values:
     - `reward_address`: Contributor's public key.
     - `registration_entrance_fee_transaction_signature`: Initially empty string.
     - `compliance_score`: Set to 1.0.
     - `last_active_timestamp`: Set to the current Unix timestamp.
     - `total_reports_submitted`: Initially 0.
     - `accurate_reports_count`: Initially 0.
     - `current_streak`: Initially 0.
     - `reliability_score`: Set to 1.0.
     - `consensus_failures`: Initially 0.
     - `ban_expiry`: Initially 0.
     - `is_eligible_for_rewards`: Initially false.
     - `is_recently_active`: Initially false.
     - `is_reliable`: Initially false.
   - This new contributor is then appended to the `contributors` vector in the `ContributorDataAccount`.

6. **Logging**:
   - Messages are logged to indicate successful registration and the contributor's public key and registration timestamp.

### 3. TXID Monitoring

**Objective**: Add TXIDs to be monitored by the oracle and track them.

#### Add TXID for Monitoring:

1. **Function Definition**:
   - The `add_txid_for_monitoring` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<AddTxidForMonitoring>` and an `AddTxidForMonitoringData` as parameters.

2. **Parameter Validation**:
   - Inside the `add_txid_for_monitoring_helper` function, the `data.txid` parameter is validated to ensure it does not exceed the maximum length (`MAX_TXID_LENGTH`). If it does, an `OracleError::InvalidTxid` error is returned.

3. **Verify Caller**:
   - The program checks that the caller's public key matches the `bridge_contract_pubkey` in the Oracle Contract State. If not, an `OracleError::NotBridgeContractAddress` error is returned. This ensures only authorized entities can add TXIDs for monitoring.

4. **Add TXID to Monitored List**:
   - The TXID is added to the `monitored_txids` vector in the Oracle Contract State. This vector keeps track of all TXIDs currently being monitored by the oracle.

5. **Initialize Pending Payment Account**:
   - A pending payment account is initialized for the TXID using the `HandlePendingPayment` context.
   - The pending payment account is initialized with the expected amount for monitoring (`COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING`) and the payment status is set to `Pending`.

6. **Logging**:
   - Messages are logged to indicate the successful addition of the TXID for monitoring and the initialization of the pending payment account.

### 4. Data Report Submission

**Objective**: Collect and validate data reports from contributors for the monitored TXIDs.

#### Submit Data Report:

1. **Function Definition**:
   - The `submit_data_report` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<SubmitDataReport>`, `txid: String`, `txid_status_str: String`, `pastel_ticket_type_str: String`, `first_6_characters_hash: String`, and `contributor_reward_address: Pubkey` as parameters.

2. **Report Creation**:
   - Inside the `submit_data_report_helper` function, the parameters are used to create a `PastelTxStatusReport` struct.
   - The `txid_status_str` is converted to the `TxidStatus` enum, and the `pastel_ticket_type_str` is converted to the `PastelTicketType` enum.
   - The current Unix timestamp is fetched and included in the report.

3. **Validation**:
   - The `validate_data_contributor_report` function is called to validate the report.
   - It ensures the TXID is not empty, the TXID status and pastel ticket type are valid, and the file hash is the correct length and contains only hex characters. If any of these validations fail, appropriate errors (e.g., `OracleError::InvalidTxid`, `OracleError::InvalidTxidStatus`, `OracleError::InvalidFileHashLength`, `OracleError::MissingFileHash`) are returned.

4. **Contributor Verification**:
   - The program checks if the contributor is registered and not banned. If the contributor's public key is not found in the `ContributorDataAccount`, an `OracleError::ContributorNotRegistered` error is returned.
   - The `calculate_is_banned` method on the `Contributor` struct is called to determine if the contributor is currently banned. If so, an `OracleError::ContributorBanned` error is returned.

5. **Common and Specific Report Data**:
   - Common report data (`CommonReportData`) is extracted from the report and either found or added to the `TempTxStatusReportAccount`.
   - Specific report data (`SpecificReportData`) is created with the contributor's reward address, timestamp, and a reference to the common data.

6. **Temporary Report Entry**:
   - A temporary report (`TempTxStatusReport`) is created with the common data reference and specific data.
   - This temporary report is added to the `TempTxStatusReportAccount`.

7. **Update Submission Count**:
   - The `update_submission_count` function is called to update the submission count for the TXID in the `TxidSubmissionCountsAccount`.

8. **Aggregate Consensus Data**:
   - The `aggregate_consensus_data` function is called to update the consensus data based on the submitted report. The contributor's compliance and reliability scores are used to weight the report.

9. **Consensus Calculation Check**:
   - The `should_calculate_consensus` function is called to determine if enough reports have been submitted to calculate consensus. If so, the `calculate_consensus` function is called to compute the consensus and update contributor scores.

10. **Logging**:
    - Messages are logged to indicate successful report submission, updated submission counts, and consensus calculation if triggered.

### 5. Consensus Calculation

**Objective**: Reach a consensus on the status and hash of each TXID based on the submitted reports.

#### Update Submission Count:

1. **Function Definition**:
   - The `update_submission_count` function is responsible for updating the submission count for a TXID.
   - It takes the `txid_submission_counts_account` and `txid` as parameters.

2. **Timestamp Retrieval**:
   - The current Unix timestamp is fetched using `Clock::get()?.unix_timestamp as u64`.

3. **Check for Existing TXID**:
   - The function checks if the TXID already exists in the submission counts.
   - If it does, the existing count is incremented, and the `last_updated` timestamp is updated.
   - If the TXID does not exist, a new `TxidSubmissionCount` entry is created with an initial count of 1 and the current timestamp.

4. **Return**:
   - The function returns `Ok(())` after updating the submission count.

#### Compute Consensus:

1. **Function Definition**:
   - The `compute_consensus` function is responsible for determining the consensus status and hash for a TXID.
   - It takes `aggregated_data` as a parameter.

2. **Status Aggregation**:
   - The function iterates over the `status_weights` array in `aggregated_data`.
   - It selects the status with the highest weight (i.e., the status reported by the most contributors) as the consensus status.

3. **Hash Aggregation**:
   - The function iterates over the `hash_weights` vector in `aggregated_data`.
   - It selects the hash with the highest weight as the consensus hash.

4. **Return**:
   - The function returns a tuple containing the consensus status and hash.

#### Update Contributor Scores:

1. **Function Definition**:
   - The `update_contributor` function is responsible for updating a contributor's compliance and reliability scores based on the accuracy of their reports.
   - It takes a mutable reference to a `Contributor`, the current timestamp, and a boolean indicating whether the report was accurate.

2. **Score Updates**:
   - If the report is accurate:
     - The contributor's `total_reports_submitted` and `accurate_reports_count` are incremented.
     - The contributor's `current_streak` is incremented.
     - The compliance score is increased based on dynamic scaling and time weight.
   - If the report is inaccurate:
     - The contributor's `total_reports_submitted` is incremented.
     - The `current_streak` is reset to 0.
     - The `consensus_failures` count is incremented.
     - The compliance score is decreased based on a penalty.

3. **Decay and Reliability Factor**:
   - The compliance score is decayed over time.
   - The reliability score is calculated based on the ratio of accurate reports to total reports.
   - The compliance score is scaled based on the reliability factor and logistic scaling.

4. **Log Scores**:
   - The updated scores are logged for debugging purposes.

#### Post-Consensus Cleanup:

1. **Function Definition**:
   - The `post_consensus_tasks` function is responsible for cleaning up old or unnecessary data after consensus is reached.
   - It takes references to `txid_submission_counts_account`, `aggregated_data_account`, `temp_report_account`, `contributor_data_account`, and the `txid`.

2. **Apply Permanent Bans**:
   - The `apply_permanent_bans` function removes contributors who have been permanently banned from the `ContributorDataAccount`.

3. **Cleanup Temporary Reports**:
   - The function retains only the temporary reports that do not match the `txid` and are within the `DATA_RETENTION_PERIOD`.

4. **Cleanup Aggregated Consensus Data**:
   - The function retains only the consensus data that is within the `DATA_RETENTION_PERIOD`.

5. **Cleanup Submission Counts**:
   - The function retains only the submission counts that are within the `SUBMISSION_COUNT_RETENTION_PERIOD`.

6. **Logging**:
   - Messages are logged to indicate the completion of cleanup tasks.

### 6. Payment Processing

**Objective**: Process payments for monitoring TXIDs and update payment status.

#### Process Payment:

1. **Function Definition**:
   - The `process_payment` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<ProcessPayment>`, `txid: String`, and `amount: u64` as parameters.

2. **Context Definition**:
   - The `ProcessPayment` context defines the accounts involved in the payment process.
   - This includes the source account, oracle contract state, and pending payment account.

3. **Function Execution**:
   - The `process_payment_helper` function is called within `process_payment` to handle the payment logic.
   - The function takes the context, TXID, and payment amount as parameters.

4. **Pending Payment Account Validation**:
   - The function first checks that the `pending_payment_account` corresponds to the provided TXID.
   - If the TXID in the `pending_payment_account` does not match the provided TXID, an error `OracleError::PaymentNotFound` is returned.

5. **Payment Amount Validation**:
   - The function ensures that the payment amount matches the expected amount in the `pending_payment_account`.
   - If the payment amount does not match, an error `OracleError::InvalidPaymentAmount` is returned.

6. **Update Payment Status**:
   - Once the payment is validated, the payment status in the `pending_payment_account` is updated to `Received`.
   - This indicates that the expected payment amount has been successfully received.

7. **Logging**:
   - Throughout the process, various log messages (`msg!`) are used to track the progress and any issues encountered.
   - This includes logging when the payment is successfully processed and if there are any validation errors.

### 7. Reward Distribution

**Objective**: Distribute rewards to eligible contributors based on their compliance and reliability scores.

#### Request Reward:

1. **Function Definition**:
   - The `request_reward` function is defined in the `solana_pastel_oracle_program` module.
   - It takes a `Context<RequestReward>` and a `contributor_address: Pubkey` as parameters.

2. **Context Definition**:
   - The `RequestReward` context defines the accounts involved in the reward distribution process.
   - This includes the reward pool account, the oracle contract state, the contributor data account, and the contributor’s account.

3. **Function Execution**:
   - The `request_reward_helper` function is called with the context and contributor's public key.

4. **Contributor Validation**:
   - The function first finds the contributor in the `ContributorDataAccount` using the provided public key.
   - If the contributor is not found, an error `OracleError::UnregisteredOracle` is returned.

5. **Eligibility Check**:
   - The function checks if the contributor meets the eligibility criteria, which include:
     - A minimum number of reports submitted.
     - Compliance score above `MIN_COMPLIANCE_SCORE_FOR_REWARD`.
     - Reliability score above `MIN_RELIABILITY_SCORE_FOR_REWARD`.
   - If the contributor is not eligible, an error `OracleError::NotEligibleForReward` is returned.

6. **Reward Amount Calculation**:
   - The reward amount is determined based on the `BASE_REWARD_AMOUNT_IN_LAMPORTS`.
   - This base amount can be scaled based on additional criteria if needed.

7. **Funds Availability Check**:
   - The function ensures that the reward pool account has sufficient funds to cover the reward amount.
   - If the reward pool has insufficient funds, an error `OracleError::InsufficientFunds` is returned.

8. **Transfer Reward**:
   - The function transfers the reward amount from the reward pool account to the contributor's account.
   - This involves decrementing the lamports in the reward pool account and incrementing the lamports in the contributor's account.

## Explanation of Typescript Testing Script

### Initialization

1. **Environment Setup**:
   - The program sets up environment variables for the Anchor provider URL and logging.
   - It initializes the Anchor provider and sets it as the default provider for the program.

2. **Program and Account Setup**:
   - The program ID and the oracle contract state account are defined.
   - Public Key Address (PDA) accounts for various purposes (e.g., reward pool, fee receiving contract, contributor data, TXID submission counts, and aggregated consensus data) are generated using `web3.PublicKey.findProgramAddressSync`.

3. **Funding the Oracle Contract State Account**:
   - The oracle contract state account is funded with enough SOL to cover the rent-exempt minimum balance required by the Solana network.

4. **Initialization and Reallocation**:
   - The program initializes the oracle contract state, setting up initial parameters and PDAs.
   - The contract state is expanded incrementally to accommodate additional data, up to a maximum size of 200KB.

### Contributor Registration

1. **Contributor Registration**:
   - Contributors are registered by generating new keypairs and paying a registration entrance fee.
   - The program transfers the registration fee to the fee receiving contract account PDA.
   - New contributors are added to the ContributorDataAccount PDA.

### TXID Monitoring

1. **Adding TXIDs for Monitoring**:
   - The program generates random TXIDs and adds them for monitoring.
   - Each TXID is associated with a pending payment account, which is initialized with the expected payment amount.
   - The TXID is then added to the monitored list in the oracle contract state.

2. **Verification of Monitored TXIDs**:
   - The program verifies that all monitored TXIDs have corresponding pending payment structs.
   - It checks the payment status and ensures the expected amount matches the defined cost.

### Data Report Submission

1. **Submitting Data Reports**:
   - Contributors submit data reports for the monitored TXIDs.
   - Reports include TXID status, pastel ticket type, and a random file hash.
   - The program handles both correct and incorrect submissions based on a predefined error probability.

2. **Consensus Data**:
   - The program aggregates consensus data for each TXID based on the submitted reports.
   - It determines the majority consensus status and logs the results.

### Payment Processing

1. **Processing Payments**:
   - The program processes payments for the monitored TXIDs by transferring the payment amount from the admin account to the fee-receiving contract PDA.
   - It updates the payment status to "Received" and verifies the changes.

### Reward Distribution

1. **Eligibility Check and Reward Distribution**:
   - The program checks if contributors meet the criteria for reward eligibility based on their compliance and reliability scores.
   - Eligible contributors receive rewards from the reward pool account PDA.
   - The program verifies that reward distribution is accurate and logs the changes in account balances.


---


---
./Cargo.lock
---
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "ahash"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9"
dependencies = [
 "getrandom 0.2.15",
 "once_cell",
 "version_check",
]

[[package]]
name = "ahash"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anchor-attribute-access-control"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47fe28365b33e8334dd70ae2f34a43892363012fe239cf37d2ee91693575b1f8"
dependencies = [
 "anchor-syn",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-attribute-account"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c288d496168268d198d9b53ee9f4f9d260a55ba4df9877ea1d4486ad6109e0f"
dependencies = [
 "anchor-syn",
 "bs58 0.5.1",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-attribute-constant"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49b77b6948d0eeaaa129ce79eea5bbbb9937375a9241d909ca8fb9e006bb6e90"
dependencies = [
 "anchor-syn",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-attribute-error"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d20bb569c5a557c86101b944721d865e1fd0a4c67c381d31a44a84f07f84828"
dependencies = [
 "anchor-syn",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-attribute-event"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cebd8d0671a3a9dc3160c48598d652c34c77de6be4d44345b8b514323284d57"
dependencies = [
 "anchor-syn",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-attribute-program"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "efb2a5eb0860e661ab31aff7bb5e0288357b176380e985bade4ccb395981b42d"
dependencies = [
 "anchor-lang-idl",
 "anchor-syn",
 "anyhow",
 "bs58 0.5.1",
 "heck",
 "proc-macro2",
 "quote",
 "serde_json",
 "syn 1.0.109",
]

[[package]]
name = "anchor-derive-accounts"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04368b5abef4266250ca8d1d12f4dff860242681e4ec22b885dcfe354fd35aa1"
dependencies = [
 "anchor-syn",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-derive-serde"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0bb0e0911ad4a70cab880cdd6287fe1e880a1a9d8e4e6defa8e9044b9796a6c"
dependencies = [
 "anchor-syn",
 "borsh-derive-internal 0.10.3",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-derive-space"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ef415ff156dc82e9ecb943189b0cb241b3a6bfc26a180234dc21bd3ef3ce0cb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "anchor-lang"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6620c9486d9d36a4389cab5e37dc34a42ed0bfaa62e6a75a2999ce98f8f2e373"
dependencies = [
 "anchor-attribute-access-control",
 "anchor-attribute-account",
 "anchor-attribute-constant",
 "anchor-attribute-error",
 "anchor-attribute-event",
 "anchor-attribute-program",
 "anchor-derive-accounts",
 "anchor-derive-serde",
 "anchor-derive-space",
 "anchor-lang-idl",
 "arrayref",
 "base64 0.21.7",
 "bincode",
 "borsh 0.10.3",
 "bytemuck",
 "getrandom 0.2.15",
 "solana-program",
 "thiserror",
]

[[package]]
name = "anchor-lang-idl"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31cf97b4e6f7d6144a05e435660fcf757dbc3446d38d0e2b851d11ed13625bba"
dependencies = [
 "anchor-lang-idl-spec",
 "anyhow",
 "heck",
 "regex",
 "serde",
 "serde_json",
 "sha2 0.10.8",
]

[[package]]
name = "anchor-lang-idl-spec"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bdf143115440fe621bdac3a29a1f7472e09f6cd82b2aa569429a0c13f103838"
dependencies = [
 "anyhow",
 "serde",
]

[[package]]
name = "anchor-syn"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f99daacb53b55cfd37ce14d6c9905929721137fd4c67bbab44a19802aecb622f"
dependencies = [
 "anyhow",
 "bs58 0.5.1",
 "cargo_toml",
 "heck",
 "proc-macro2",
 "quote",
 "serde",
 "serde_json",
 "sha2 0.10.8",
 "syn 1.0.109",
 "thiserror",
]

[[package]]
name = "anyhow"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3d1d046238990b9cf5bcde22a3fb3584ee5cf65fb2765f454ed428c7a0063da"

[[package]]
name = "ark-bn254"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a22f4561524cd949590d78d7d4c5df8f592430d221f7f3c9497bbafd8972120f"
dependencies = [
 "ark-ec",
 "ark-ff",
 "ark-std",
]

[[package]]
name = "ark-ec"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "defd9a439d56ac24968cca0571f598a61bc8c55f71d50a89cda591cb750670ba"
dependencies = [
 "ark-ff",
 "ark-poly",
 "ark-serialize",
 "ark-std",
 "derivative",
 "hashbrown 0.13.2",
 "itertools",
 "num-traits",
 "zeroize",
]

[[package]]
name = "ark-ff"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec847af850f44ad29048935519032c33da8aa03340876d351dfab5660d2966ba"
dependencies = [
 "ark-ff-asm",
 "ark-ff-macros",
 "ark-serialize",
 "ark-std",
 "derivative",
 "digest 0.10.7",
 "itertools",
 "num-bigint",
 "num-traits",
 "paste",
 "rustc_version",
 "zeroize",
]

[[package]]
name = "ark-ff-asm"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ed4aa4fe255d0bc6d79373f7e31d2ea147bcf486cba1be5ba7ea85abdb92348"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-ff-macros"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7abe79b0e4288889c4574159ab790824d0033b9fdcb2a112a3182fac2e514565"
dependencies = [
 "num-bigint",
 "num-traits",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-poly"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d320bfc44ee185d899ccbadfa8bc31aab923ce1558716e1997a1e74057fe86bf"
dependencies = [
 "ark-ff",
 "ark-serialize",
 "ark-std",
 "derivative",
 "hashbrown 0.13.2",
]

[[package]]
name = "ark-serialize"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adb7b85a02b83d2f22f89bd5cac66c9c89474240cb6207cb1efc16d098e822a5"
dependencies = [
 "ark-serialize-derive",
 "ark-std",
 "digest 0.10.7",
 "num-bigint",
]

[[package]]
name = "ark-serialize-derive"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae3281bc6d0fd7e549af32b52511e1302185bd688fd3359fa36423346ff682ea"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-std"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94893f1e0c6eeab764ade8dc4c0db24caf4fe7cbbaafc0eba0a9030f447b5185"
dependencies = [
 "num-traits",
 "rand 0.8.5",
]

[[package]]
name = "arrayref"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"

[[package]]
name = "arrayvec"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "az"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b7e4c2464d97fe331d41de9d5db0def0a96f4d823b8b32a2efd503578988973"

[[package]]
name = "base64"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3441f0f7b02788e948e47f457ca01f1d7e6d92c693bc132c22b087d3141c03ff"

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "bincode"
version = "1.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1f45e9417d87227c7a56d22e471c6206462cba514c7590c09aff4cf6d1ddcad"
dependencies = [
 "serde",
]

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"
dependencies = [
 "serde",
]

[[package]]
name = "bitmaps"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "031043d04099746d8db04daf1fa424b2bc8bd69d92b25962dcde24da39ab64a2"
dependencies = [
 "typenum",
]

[[package]]
name = "blake3"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30cca6d3674597c30ddf2c587bf8d9d65c9a84d2326d941cc79c9842dfe0ef52"
dependencies = [
 "arrayref",
 "arrayvec",
 "cc",
 "cfg-if",
 "constant_time_eq",
 "digest 0.10.7",
]

[[package]]
name = "block-buffer"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "borsh"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15bf3650200d8bffa99015595e10f1fbd17de07abbc25bb067da79e769939bfa"
dependencies = [
 "borsh-derive 0.9.3",
 "hashbrown 0.11.2",
]

[[package]]
name = "borsh"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4114279215a005bc675e386011e594e1d9b800918cea18fcadadcce864a2046b"
dependencies = [
 "borsh-derive 0.10.3",
 "hashbrown 0.13.2",
]

[[package]]
name = "borsh"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6362ed55def622cddc70a4746a68554d7b687713770de539e59a739b249f8ed"
dependencies = [
 "borsh-derive 1.5.1",
 "cfg_aliases",
]

[[package]]
name = "borsh-derive"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6441c552f230375d18e3cc377677914d2ca2b0d36e52129fe15450a2dce46775"
dependencies = [
 "borsh-derive-internal 0.9.3",
 "borsh-schema-derive-internal 0.9.3",
 "proc-macro-crate 0.1.5",
 "proc-macro2",
 "syn 1.0.109",
]

[[package]]
name = "borsh-derive"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0754613691538d51f329cce9af41d7b7ca150bc973056f1156611489475f54f7"
dependencies = [
 "borsh-derive-internal 0.10.3",
 "borsh-schema-derive-internal 0.10.3",
 "proc-macro-crate 0.1.5",
 "proc-macro2",
 "syn 1.0.109",
]

[[package]]
name = "borsh-derive"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3ef8005764f53cd4dca619f5bf64cafd4664dada50ece25e4d81de54c80cc0b"
dependencies = [
 "once_cell",
 "proc-macro-crate 3.1.0",
 "proc-macro2",
 "quote",
 "syn 2.0.70",
 "syn_derive",
]

[[package]]
name = "borsh-derive-internal"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5449c28a7b352f2d1e592a8a28bf139bc71afb0764a14f3c02500935d8c44065"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "borsh-derive-internal"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afb438156919598d2c7bad7e1c0adf3d26ed3840dbc010db1a882a65583ca2fb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "borsh-schema-derive-internal"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdbd5696d8bfa21d53d9fe39a714a18538bad11492a42d066dbbc395fb1951c0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "borsh-schema-derive-internal"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "634205cc43f74a1b9046ef87c4540ebda95696ec0f315024860cad7c5b0f5ccd"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "bs58"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "771fe0050b883fcc3ea2359b1a96bcfbc090b7116eae7c3c512c7a083fdf23d3"

[[package]]
name = "bs58"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf88ba1141d185c399bee5288d850d63b8369520c1eafc32a0430b5b6c287bf4"
dependencies = [
 "tinyvec",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "bv"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8834bb1d8ee5dc048ee3124f2c7c1afcc6bc9aed03f11e9dfd8c69470a5db340"
dependencies = [
 "feature-probe",
 "serde",
]

[[package]]
name = "bytemuck"
version = "1.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b236fc92302c97ed75b38da1f4917b5cdda4984745740f153a5d3059e48d725e"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ee891b04274a59bd38b412188e24b849617b2e45a0fd8d057deb63e7403761b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "cargo_toml"
version = "0.19.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a98356df42a2eb1bd8f1793ae4ee4de48e384dd974ce5eac8eee802edb7492be"
dependencies = [
 "serde",
 "toml 0.8.14",
]

[[package]]
name = "cc"
version = "1.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96c51067fd44124faa7f870b4b1c969379ad32b2ba805aa959430ceaa384f695"
dependencies = [
 "jobserver",
 "libc",
 "once_cell",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "console_error_panic_hook"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06aeb73f470f66dcdbf7223caeebb85984942f22f1adb2a088cf9668146bbbc"
dependencies = [
 "cfg-if",
 "wasm-bindgen",
]

[[package]]
name = "console_log"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89f72f65e8501878b8a004d5a1afb780987e2ce2b4532c562e367a72c57499f"
dependencies = [
 "log",
 "web-sys",
]

[[package]]
name = "constant_time_eq"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7144d30dcf0fafbce74250a3963025d8d52177934239851c917d29f1df280c2"

[[package]]
name = "cpufeatures"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504"
dependencies = [
 "libc",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"

[[package]]
name = "crunchy"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "crypto-mac"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b584a330336237c1eecd3e94266efb216c56ed91225d634cb2991c5f3fd1aeab"
dependencies = [
 "generic-array",
 "subtle",
]

[[package]]
name = "curve25519-dalek"
version = "3.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90f9d052967f590a76e62eb387bd0bbb1b000182c3cefe5364db6b7211651bc0"
dependencies = [
 "byteorder",
 "digest 0.9.0",
 "rand_core 0.5.1",
 "serde",
 "subtle",
 "zeroize",
]

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "digest"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
dependencies = [
 "generic-array",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer 0.10.4",
 "crypto-common",
 "subtle",
]

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "feature-probe"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "835a3dc7d1ec9e75e2b5fb4ba75396837112d2060b03f7d43bc1897c7f7211da"

[[package]]
name = "fixed"
version = "1.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fc715d38bea7b5bf487fcd79bcf8c209f0b58014f3018a7a19c2b855f472048"
dependencies = [
 "az",
 "bytemuck",
 "half",
 "typenum",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "serde",
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.9.0+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "half"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dd08c532ae367adf81c312a4580bc67f1d0fe8bc9c460520283f4c0ff277888"
dependencies = [
 "cfg-if",
 "crunchy",
]

[[package]]
name = "hashbrown"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e"
dependencies = [
 "ahash 0.7.8",
]

[[package]]
name = "hashbrown"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43a3c133739dddd0d2990f9a4bdf8eb4b21ef50e4851ca85ab661199821d510e"
dependencies = [
 "ahash 0.8.11",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "heck"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hmac"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "126888268dcc288495a26bf004b38c5fdbb31682f992c84ceb046a1f0fe38840"
dependencies = [
 "crypto-mac",
 "digest 0.9.0",
]

[[package]]
name = "hmac-drbg"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17ea0a1394df5b6574da6e0c1ade9e78868c9fb0a4e5ef4428e32da4676b85b1"
dependencies = [
 "digest 0.9.0",
 "generic-array",
 "hmac",
]

[[package]]
name = "im"
version = "15.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0acd33ff0285af998aaf9b57342af478078f53492322fafc47450e09397e0e9"
dependencies = [
 "bitmaps",
 "rand_core 0.6.4",
 "rand_xoshiro",
 "rayon",
 "serde",
 "sized-chunks",
 "typenum",
 "version_check",
]

[[package]]
name = "indexmap"
version = "2.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "168fb715dda47215e360912c096649d23d58bf392ac62f73919e831745e40f26"
dependencies = [
 "equivalent",
 "hashbrown 0.14.5",
]

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "jobserver"
version = "0.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2b099aaa34a9751c5bf0878add70444e1ed2dd73f347be99003d4577277de6e"
dependencies = [
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29c15563dc2726973df627357ce0c9ddddbea194836909d655df6a75d2cf296d"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.155"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97b3888a4aecf77e811145cadf6eef5901f4782c53886191b2f693f24761847c"

[[package]]
name = "libsecp256k1"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9d220bc1feda2ac231cb78c3d26f27676b8cf82c96971f7aeef3d0cf2797c73"
dependencies = [
 "arrayref",
 "base64 0.12.3",
 "digest 0.9.0",
 "hmac-drbg",
 "libsecp256k1-core",
 "libsecp256k1-gen-ecmult",
 "libsecp256k1-gen-genmult",
 "rand 0.7.3",
 "serde",
 "sha2 0.9.9",
 "typenum",
]

[[package]]
name = "libsecp256k1-core"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0f6ab710cec28cef759c5f18671a27dae2a5f952cdaaee1d8e2908cb2478a80"
dependencies = [
 "crunchy",
 "digest 0.9.0",
 "subtle",
]

[[package]]
name = "libsecp256k1-gen-ecmult"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccab96b584d38fac86a83f07e659f0deafd0253dc096dab5a36d53efe653c5c3"
dependencies = [
 "libsecp256k1-core",
]

[[package]]
name = "libsecp256k1-gen-genmult"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67abfe149395e3aa1c48a2beb32b068e2334402df8181f818d3aee2b304c4f5d"
dependencies = [
 "libsecp256k1-core",
]

[[package]]
name = "light-poseidon"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c9a85a9752c549ceb7578064b4ed891179d20acd85f27318573b64d2d7ee7ee"
dependencies = [
 "ark-bn254",
 "ark-ff",
 "num-bigint",
 "thiserror",
]

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memmap2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
dependencies = [
 "autocfg",
]

[[package]]
name = "num-bigint"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
dependencies = [
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-derive"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pbkdf2"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "216eaa586a190f0a738f2f918511eecfa90f13295abec0e457cdebcceda80cbd"
dependencies = [
 "crypto-mac",
]

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "proc-macro-crate"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d6ea3c4595b96363c13943497db34af4460fb474a95c43f4446ad341b8c9785"
dependencies = [
 "toml 0.5.11",
]

[[package]]
name = "proc-macro-crate"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d37c51ca738a55da99dc0c4a34860fd675453b8b36209178c2249bb13651284"
dependencies = [
 "toml_edit 0.21.1",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
dependencies = [
 "getrandom 0.1.16",
 "libc",
 "rand_chacha 0.2.2",
 "rand_core 0.5.1",
 "rand_hc",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
dependencies = [
 "ppv-lite86",
 "rand_core 0.5.1",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_core"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
dependencies = [
 "getrandom 0.1.16",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.15",
]

[[package]]
name = "rand_hc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "rand_xoshiro"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f97cdb2a36ed4183de61b2f824cc45c9f1037f28afe0a322e9fff4c108b5aaa"
dependencies = [
 "rand_core 0.6.4",
]

[[package]]
name = "rayon"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c82cf8cff14456045f55ec4241383baeff27af886adb72ffb2162f99911de0fd"
dependencies = [
 "bitflags",
]

[[package]]
name = "regex"
version = "1.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91213439dad192326a0d7c6ee3955910425f441d7038e0d6933b0aec5c4517f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc_version"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
dependencies = [
 "semver",
]

[[package]]
name = "rustversion"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "955d28af4278de8121b7ebeb796b6a45735dc01436d898801014aced2773a3d6"

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61697e0a1c7e512e84a621326239844a24d8207b4669b41bc18b32ea5cbf988b"

[[package]]
name = "serde"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc76f558e0cbb2a839d37354c575f1dc3fdc6546b5be373ba43d95f231bf7c12"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_bytes"
version = "0.11.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "387cc504cb06bb40a96c8e04e951fe01854cf6bc921053c954e4a606d9675c6a"
dependencies = [
 "serde",
]

[[package]]
name = "serde_derive"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0cd7e117be63d3c3678776753929474f3b04a43a080c744d6b0ae2a8c28e222"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]

[[package]]
name = "serde_json"
version = "1.0.120"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e0d21c9a8cae1235ad58a00c11cb40d4b1e5c784f1ef2c537876ed6ffd8b7c5"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79e674e01f999af37c49f70a6ede167a8a60b2503e56c5599532a65baa5969a0"
dependencies = [
 "serde",
]

[[package]]
name = "sha2"
version = "0.9.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d58a1e1bf39749807d89cf2d98ac2dfa0ff1cb3faa38fbb64dd88ac8013d800"
dependencies = [
 "block-buffer 0.9.0",
 "cfg-if",
 "cpufeatures",
 "digest 0.9.0",
 "opaque-debug",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest 0.10.7",
 "keccak",
]

[[package]]
name = "sized-chunks"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16d69225bde7a69b235da73377861095455d298f2b970996eec25ddbb42b3d1e"
dependencies = [
 "bitmaps",
 "typenum",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "solana-frozen-abi"
version = "1.18.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f498a2b290abca1cf77feacef01b904be725fd46a7aea5ba121cce8c1269dcf"
dependencies = [
 "block-buffer 0.10.4",
 "bs58 0.4.0",
 "bv",
 "either",
 "generic-array",
 "im",
 "lazy_static",
 "log",
 "memmap2",
 "rustc_version",
 "serde",
 "serde_bytes",
 "serde_derive",
 "sha2 0.10.8",
 "solana-frozen-abi-macro",
 "subtle",
 "thiserror",
]

[[package]]
name = "solana-frozen-abi-macro"
version = "1.18.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4ab48d1be18021f5c13f94671e766699511044f81aab3376313f6a2392f8fab"
dependencies = [
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 2.0.70",
]

[[package]]
name = "solana-program"
version = "1.18.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d97cec6d3d60ef58168c8b3e97fd88e8903fa059eff6635361427c61c946ec1e"
dependencies = [
 "ark-bn254",
 "ark-ec",
 "ark-ff",
 "ark-serialize",
 "base64 0.21.7",
 "bincode",
 "bitflags",
 "blake3",
 "borsh 0.10.3",
 "borsh 0.9.3",
 "borsh 1.5.1",
 "bs58 0.4.0",
 "bv",
 "bytemuck",
 "cc",
 "console_error_panic_hook",
 "console_log",
 "curve25519-dalek",
 "getrandom 0.2.15",
 "itertools",
 "js-sys",
 "lazy_static",
 "libc",
 "libsecp256k1",
 "light-poseidon",
 "log",
 "memoffset",
 "num-bigint",
 "num-derive",
 "num-traits",
 "parking_lot",
 "rand 0.8.5",
 "rustc_version",
 "rustversion",
 "serde",
 "serde_bytes",
 "serde_derive",
 "serde_json",
 "sha2 0.10.8",
 "sha3",
 "solana-frozen-abi",
 "solana-frozen-abi-macro",
 "solana-sdk-macro",
 "thiserror",
 "tiny-bip39",
 "wasm-bindgen",
 "zeroize",
]

[[package]]
name = "solana-sdk-macro"
version = "1.18.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ba67050b90454a8638913a7d5775703c0557157def04ddcc8b59c964cda8535"
dependencies = [
 "bs58 0.4.0",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.70",
]

[[package]]
name = "solana_pastel_oracle_program"
version = "0.1.0"
dependencies = [
 "anchor-lang",
 "fixed",
 "num-traits",
 "typenum",
 "uint",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.70"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0209b68b3613b093e0ec905354eccaedcfe83b8cb37cbdeae64026c3064c16"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn_derive"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1329189c02ff984e9736652b1631330da25eaa6bc639089ed4915d25446cbe7b"
dependencies = [
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]

[[package]]
name = "thiserror"
version = "1.0.62"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2675633b1499176c2dff06b0856a27976a8f9d436737b4cf4f312d4d91d8bbb"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.62"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d20468752b09f49e909e55a5d338caa8bedf615594e9d80bc4c565d30faf798c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]

[[package]]
name = "tiny-bip39"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffc59cb9dfc85bb312c3a78fd6aa8a8582e310b0fa885d5bb877f6dcc601839d"
dependencies = [
 "anyhow",
 "hmac",
 "once_cell",
 "pbkdf2",
 "rand 0.7.3",
 "rustc-hash",
 "sha2 0.9.9",
 "thiserror",
 "unicode-normalization",
 "wasm-bindgen",
 "zeroize",
]

[[package]]
name = "tinyvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "toml"
version = "0.8.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f49eb2ab21d2f26bd6db7bf383edc527a7ebaee412d17af4d40fdccd442f335"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit 0.22.15",
]

[[package]]
name = "toml_datetime"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4badfd56924ae69bcc9039335b2e017639ce3f9b001c393c1b2d1ef846ce2cbf"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8534fd7f78b5405e860340ad6575217ce99f38d4d5c8f2442cb5ecb50090e1"
dependencies = [
 "indexmap",
 "toml_datetime",
 "winnow 0.5.40",
]

[[package]]
name = "toml_edit"
version = "0.22.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d59a3a72298453f564e2b111fa896f8d07fabb36f51f06d7e875fc5e0b5a3ef1"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "winnow 0.6.13",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "uint"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52"
dependencies = [
 "byteorder",
 "crunchy",
 "hex",
 "static_assertions",
]

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-normalization"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-segmentation"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "wasi"
version = "0.9.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4be2531df63900aeb2bca0daaaddec08491ee64ceecbee5076636a3b026795a8"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "614d787b966d3989fa7bb98a654e369c762374fd3213d212cfc0251257e747da"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.70",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af190c94f2773fdb3729c55b007a722abb5384da03bc0986df4c289bf5567e96"

[[package]]
name = "web-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77afa9a11836342370f4817622a2f0f418b134426d91a82dfb48f532d2ec13ef"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
dependencies = [
 "memchr",
]

[[package]]
name = "winnow"
version = "0.6.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59b5e5f6c299a3c7890b876a2a587f3115162487e704907d9b6cd29473052ba1"
dependencies = [
 "memchr",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]

[[package]]
name = "zeroize"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4756f7db3f7b5574938c3eb1c117038b8e07f95ee6718c0efad4ac21508f1efd"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.70",
]


---
./yarn.lock
---
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


"@babel/runtime@^7.25.0":
  version "7.25.6"
  resolved "https://registry.yarnpkg.com/@babel/runtime/-/runtime-7.25.6.tgz#9afc3289f7184d8d7f98b099884c26317b9264d2"
  integrity sha512-VBj9MYyDb9tuLq7yzqjgzt6Q+IBQLrGZfdjOekyEirZPHxXWoTSGUTMrpsfi58Up73d13NfYLv8HT9vmznjzhQ==
  dependencies:
    regenerator-runtime "^0.14.0"

"@coral-xyz/anchor-errors@^0.30.1":
  version "0.30.1"
  resolved "https://registry.yarnpkg.com/@coral-xyz/anchor-errors/-/anchor-errors-0.30.1.tgz#bdfd3a353131345244546876eb4afc0e125bec30"
  integrity sha512-9Mkradf5yS5xiLWrl9WrpjqOrAV+/W2RQHDlbnAZBivoGpOs1ECjoDCkVk4aRG8ZdiFiB8zQEVlxf+8fKkmSfQ==

"@coral-xyz/anchor@^0.30.1":
  version "0.30.1"
  resolved "https://registry.yarnpkg.com/@coral-xyz/anchor/-/anchor-0.30.1.tgz#17f3e9134c28cd0ea83574c6bab4e410bcecec5d"
  integrity sha512-gDXFoF5oHgpriXAaLpxyWBHdCs8Awgf/gLHIo6crv7Aqm937CNdY+x+6hoj7QR5vaJV7MxWSQ0NGFzL3kPbWEQ==
  dependencies:
    "@coral-xyz/anchor-errors" "^0.30.1"
    "@coral-xyz/borsh" "^0.30.1"
    "@noble/hashes" "^1.3.1"
    "@solana/web3.js" "^1.68.0"
    bn.js "^5.1.2"
    bs58 "^4.0.1"
    buffer-layout "^1.2.2"
    camelcase "^6.3.0"
    cross-fetch "^3.1.5"
    crypto-hash "^1.3.0"
    eventemitter3 "^4.0.7"
    pako "^2.0.3"
    snake-case "^3.0.4"
    superstruct "^0.15.4"
    toml "^3.0.0"

"@coral-xyz/borsh@^0.30.1":
  version "0.30.1"
  resolved "https://registry.yarnpkg.com/@coral-xyz/borsh/-/borsh-0.30.1.tgz#869d8833abe65685c72e9199b8688477a4f6b0e3"
  integrity sha512-aaxswpPrCFKl8vZTbxLssA2RvwX2zmKLlRCIktJOwW+VpVwYtXRtlWiIP+c2pPRKneiTiWCN2GEMSH9j1zTlWQ==
  dependencies:
    bn.js "^5.1.2"
    buffer-layout "^1.2.0"

"@noble/curves@^1.4.2":
  version "1.6.0"
  resolved "https://registry.yarnpkg.com/@noble/curves/-/curves-1.6.0.tgz#be5296ebcd5a1730fccea4786d420f87abfeb40b"
  integrity sha512-TlaHRXDehJuRNR9TfZDNQ45mMEd5dwUwmicsafcIX4SsNiqnCHKjE/1alYPd/lDRVhxdhUAlv8uEhMCI5zjIJQ==
  dependencies:
    "@noble/hashes" "1.5.0"

"@noble/hashes@1.5.0", "@noble/hashes@^1.3.1", "@noble/hashes@^1.4.0":
  version "1.5.0"
  resolved "https://registry.yarnpkg.com/@noble/hashes/-/hashes-1.5.0.tgz#abadc5ca20332db2b1b2aa3e496e9af1213570b0"
  integrity sha512-1j6kQFb7QRru7eKN3ZDvRcP13rugwdxZqCjbiAVZfIJwgj2A65UmT4TgARXGlXgnRkORLTDTrO19ZErt7+QXgA==

"@solana/buffer-layout@^4.0.1":
  version "4.0.1"
  resolved "https://registry.yarnpkg.com/@solana/buffer-layout/-/buffer-layout-4.0.1.tgz#b996235eaec15b1e0b5092a8ed6028df77fa6c15"
  integrity sha512-E1ImOIAD1tBZFRdjeM4/pzTiTApC0AOBGwyAMS4fwIodCWArzJ3DWdoh8cKxeFM2fElkxBh2Aqts1BPC373rHA==
  dependencies:
    buffer "~6.0.3"

"@solana/web3.js@^1.68.0", "@solana/web3.js@^1.88.0":
  version "1.95.3"
  resolved "https://registry.yarnpkg.com/@solana/web3.js/-/web3.js-1.95.3.tgz#70b5f4d76823f56b5af6403da51125fffeb65ff3"
  integrity sha512-O6rPUN0w2fkNqx/Z3QJMB9L225Ex10PRDH8bTaIUPZXMPV0QP8ZpPvjQnXK+upUczlRgzHzd6SjKIha1p+I6og==
  dependencies:
    "@babel/runtime" "^7.25.0"
    "@noble/curves" "^1.4.2"
    "@noble/hashes" "^1.4.0"
    "@solana/buffer-layout" "^4.0.1"
    agentkeepalive "^4.5.0"
    bigint-buffer "^1.1.5"
    bn.js "^5.2.1"
    borsh "^0.7.0"
    bs58 "^4.0.1"
    buffer "6.0.3"
    fast-stable-stringify "^1.0.0"
    jayson "^4.1.1"
    node-fetch "^2.7.0"
    rpc-websockets "^9.0.2"
    superstruct "^2.0.2"

"@swc/helpers@^0.5.11":
  version "0.5.13"
  resolved "https://registry.yarnpkg.com/@swc/helpers/-/helpers-0.5.13.tgz#33e63ff3cd0cade557672bd7888a39ce7d115a8c"
  integrity sha512-UoKGxQ3r5kYI9dALKJapMmuK+1zWM/H17Z1+iwnNmzcJRnfFuevZs375TA5rW31pu4BS4NoSy1fRsexDXfWn5w==
  dependencies:
    tslib "^2.4.0"

"@types/bn.js@^5.1.0":
  version "5.1.6"
  resolved "https://registry.yarnpkg.com/@types/bn.js/-/bn.js-5.1.6.tgz#9ba818eec0c85e4d3c679518428afdf611d03203"
  integrity sha512-Xh8vSwUeMKeYYrj3cX4lGQgFSF/N03r+tv4AiLl1SucqV+uTQpxRcnM8AkXKHwYP9ZPXOYXRr2KPXpVlIvqh9w==
  dependencies:
    "@types/node" "*"

"@types/chai@^4.3.0":
  version "4.3.19"
  resolved "https://registry.yarnpkg.com/@types/chai/-/chai-4.3.19.tgz#14519f437361d41e84102ed3fbc922ddace3e228"
  integrity sha512-2hHHvQBVE2FiSK4eN0Br6snX9MtolHaTo/batnLjlGRhoQzlCL61iVpxoqO7SfFyOw+P/pwv+0zNHzKoGWz9Cw==

"@types/connect@^3.4.33":
  version "3.4.38"
  resolved "https://registry.yarnpkg.com/@types/connect/-/connect-3.4.38.tgz#5ba7f3bc4fbbdeaff8dded952e5ff2cc53f8d858"
  integrity sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==
  dependencies:
    "@types/node" "*"

"@types/decimal.js@^7.4.0":
  version "7.4.0"
  resolved "https://registry.yarnpkg.com/@types/decimal.js/-/decimal.js-7.4.0.tgz#0289c1903c31a4e9b94caa741916a9bc64d1c585"
  integrity sha512-TiP45voN8GdDib9QkkdMprTfs86xxHInqTxNPSGbF0m6X0LXVBjkFEKbbL9fqm4ZPoVFkG1p4F26on2MWGvW5w==
  dependencies:
    decimal.js "*"

"@types/json5@^0.0.29":
  version "0.0.29"
  resolved "https://registry.yarnpkg.com/@types/json5/-/json5-0.0.29.tgz#ee28707ae94e11d2b827bcbe5270bcea7f3e71ee"
  integrity sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==

"@types/mocha@^9.0.0":
  version "9.1.1"
  resolved "https://registry.yarnpkg.com/@types/mocha/-/mocha-9.1.1.tgz#e7c4f1001eefa4b8afbd1eee27a237fee3bf29c4"
  integrity sha512-Z61JK7DKDtdKTWwLeElSEBcWGRLY8g95ic5FoQqI9CMx0ns/Ghep3B4DfcEimiKMvtamNVULVNKEsiwV3aQmXw==

"@types/node@*":
  version "22.5.5"
  resolved "https://registry.yarnpkg.com/@types/node/-/node-22.5.5.tgz#52f939dd0f65fc552a4ad0b392f3c466cc5d7a44"
  integrity sha512-Xjs4y5UPO/CLdzpgR6GirZJx36yScjh73+2NlLlkFRSoQN8B0DpfXPdZGnvVmLRLOsqDpOfTNv7D9trgGhmOIA==
  dependencies:
    undici-types "~6.19.2"

"@types/node@^12.12.54":
  version "12.20.55"
  resolved "https://registry.yarnpkg.com/@types/node/-/node-12.20.55.tgz#c329cbd434c42164f846b909bd6f85b5537f6240"
  integrity sha512-J8xLz7q2OFulZ2cyGTLE1TbbZcjpno7FaN6zdJNrgAdrJ+DZzh/uFR6YrTb4C+nXakvud8Q4+rbhoIWlYQbUFQ==

"@types/uuid@^8.3.4":
  version "8.3.4"
  resolved "https://registry.yarnpkg.com/@types/uuid/-/uuid-8.3.4.tgz#bd86a43617df0594787d38b735f55c805becf1bc"
  integrity sha512-c/I8ZRb51j+pYGAu5CrFMRxqZ2ke4y2grEBO5AUjgSkSk+qT2Ea+OdWElz/OiMf5MNpn2b17kuVBwZLQJXzihw==

"@types/ws@^7.4.4":
  version "7.4.7"
  resolved "https://registry.yarnpkg.com/@types/ws/-/ws-7.4.7.tgz#f7c390a36f7a0679aa69de2d501319f4f8d9b702"
  integrity sha512-JQbbmxZTZehdc2iszGKs5oC3NFnjeay7mtAWrdt7qNtAVK0g19muApzAy4bm9byz79xa2ZnO/BOBC2R8RC5Lww==
  dependencies:
    "@types/node" "*"

"@types/ws@^8.2.2":
  version "8.5.12"
  resolved "https://registry.yarnpkg.com/@types/ws/-/ws-8.5.12.tgz#619475fe98f35ccca2a2f6c137702d85ec247b7e"
  integrity sha512-3tPRkv1EtkDpzlgyKyI8pGsGZAGPEaXeu0DOj5DI25Ja91bdAYddYHbADRYVrZMRbfW+1l5YwXVDKohDJNQxkQ==
  dependencies:
    "@types/node" "*"

"@ungap/promise-all-settled@1.1.2":
  version "1.1.2"
  resolved "https://registry.yarnpkg.com/@ungap/promise-all-settled/-/promise-all-settled-1.1.2.tgz#aa58042711d6e3275dd37dc597e5d31e8c290a44"
  integrity sha512-sL/cEvJWAnClXw0wHk85/2L0G6Sj8UB0Ctc1TEMbKSsmpRosqhwj9gWgFRZSrBr2f9tiXISwNhCPmlfqUqyb9Q==

JSONStream@^1.3.5:
  version "1.3.5"
  resolved "https://registry.yarnpkg.com/JSONStream/-/JSONStream-1.3.5.tgz#3208c1f08d3a4d99261ab64f92302bc15e111ca0"
  integrity sha512-E+iruNOY8VV9s4JEbe1aNEm6MiszPRr/UfcHMz0TQh1BXSxHK+ASV1R6W4HpjBhSeS+54PIsAMCBmwD06LLsqQ==
  dependencies:
    jsonparse "^1.2.0"
    through ">=2.2.7 <3"

agentkeepalive@^4.5.0:
  version "4.5.0"
  resolved "https://registry.yarnpkg.com/agentkeepalive/-/agentkeepalive-4.5.0.tgz#2673ad1389b3c418c5a20c5d7364f93ca04be923"
  integrity sha512-5GG/5IbQQpC9FpkRGsSvZI5QYeSCzlJHdpBQntCsuTOxhKD8lqKhrleg2Yi7yvMIf82Ycmmqln9U8V9qwEiJew==
  dependencies:
    humanize-ms "^1.2.1"

ansi-colors@4.1.1:
  version "4.1.1"
  resolved "https://registry.yarnpkg.com/ansi-colors/-/ansi-colors-4.1.1.tgz#cbb9ae256bf750af1eab344f229aa27fe94ba348"
  integrity sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==

ansi-regex@^5.0.1:
  version "5.0.1"
  resolved "https://registry.yarnpkg.com/ansi-regex/-/ansi-regex-5.0.1.tgz#082cb2c89c9fe8659a311a53bd6a4dc5301db304"
  integrity sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==

ansi-styles@^4.0.0, ansi-styles@^4.1.0:
  version "4.3.0"
  resolved "https://registry.yarnpkg.com/ansi-styles/-/ansi-styles-4.3.0.tgz#edd803628ae71c04c85ae7a0906edad34b648937"
  integrity sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==
  dependencies:
    color-convert "^2.0.1"

anymatch@~3.1.2:
  version "3.1.3"
  resolved "https://registry.yarnpkg.com/anymatch/-/anymatch-3.1.3.tgz#790c58b19ba1720a84205b57c618d5ad8524973e"
  integrity sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==
  dependencies:
    normalize-path "^3.0.0"
    picomatch "^2.0.4"

argparse@^2.0.1:
  version "2.0.1"
  resolved "https://registry.yarnpkg.com/argparse/-/argparse-2.0.1.tgz#246f50f3ca78a3240f6c997e8a9bd1eac49e4b38"
  integrity sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==

arrify@^1.0.0:
  version "1.0.1"
  resolved "https://registry.yarnpkg.com/arrify/-/arrify-1.0.1.tgz#898508da2226f380df904728456849c1501a4b0d"
  integrity sha512-3CYzex9M9FGQjCGMGyi6/31c8GJbgb0qGyrx5HWxPd0aCwh4cB2YjMb2Xf9UuoogrMrlO9cTqnB5rI5GHZTcUA==

assertion-error@^1.1.0:
  version "1.1.0"
  resolved "https://registry.yarnpkg.com/assertion-error/-/assertion-error-1.1.0.tgz#e60b6b0e8f301bd97e5375215bda406c85118c0b"
  integrity sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==

balanced-match@^1.0.0:
  version "1.0.2"
  resolved "https://registry.yarnpkg.com/balanced-match/-/balanced-match-1.0.2.tgz#e83e3a7e3f300b34cb9d87f615fa0cbf357690ee"
  integrity sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==

base-x@^3.0.2:
  version "3.0.10"
  resolved "https://registry.yarnpkg.com/base-x/-/base-x-3.0.10.tgz#62de58653f8762b5d6f8d9fe30fa75f7b2585a75"
  integrity sha512-7d0s06rR9rYaIWHkpfLIFICM/tkSVdoPC9qYAQRpxn9DdKNWNsKC0uk++akckyLq16Tx2WIinnZ6WRriAt6njQ==
  dependencies:
    safe-buffer "^5.0.1"

base-x@^4.0.0:
  version "4.0.0"
  resolved "https://registry.yarnpkg.com/base-x/-/base-x-4.0.0.tgz#d0e3b7753450c73f8ad2389b5c018a4af7b2224a"
  integrity sha512-FuwxlW4H5kh37X/oW59pwTzzTKRzfrrQwhmyspRM7swOEZcHtDZSCt45U6oKgtuFE+WYPblePMVIPR4RZrh/hw==

base64-js@^1.3.1:
  version "1.5.1"
  resolved "https://registry.yarnpkg.com/base64-js/-/base64-js-1.5.1.tgz#1b1b440160a5bf7ad40b650f095963481903930a"
  integrity sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==

bigint-buffer@^1.1.5:
  version "1.1.5"
  resolved "https://registry.yarnpkg.com/bigint-buffer/-/bigint-buffer-1.1.5.tgz#d038f31c8e4534c1f8d0015209bf34b4fa6dd442"
  integrity sha512-trfYco6AoZ+rKhKnxA0hgX0HAbVP/s808/EuDSe2JDzUnCp/xAsli35Orvk67UrTEcwuxZqYZDmfA2RXJgxVvA==
  dependencies:
    bindings "^1.3.0"

binary-extensions@^2.0.0:
  version "2.3.0"
  resolved "https://registry.yarnpkg.com/binary-extensions/-/binary-extensions-2.3.0.tgz#f6e14a97858d327252200242d4ccfe522c445522"
  integrity sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==

bindings@^1.3.0:
  version "1.5.0"
  resolved "https://registry.yarnpkg.com/bindings/-/bindings-1.5.0.tgz#10353c9e945334bc0511a6d90b38fbc7c9c504df"
  integrity sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==
  dependencies:
    file-uri-to-path "1.0.0"

bn.js@^5.1.2, bn.js@^5.2.0, bn.js@^5.2.1:
  version "5.2.1"
  resolved "https://registry.yarnpkg.com/bn.js/-/bn.js-5.2.1.tgz#0bc527a6a0d18d0aa8d5b0538ce4a77dccfa7b70"
  integrity sha512-eXRvHzWyYPBuB4NBy0cmYQjGitUrtqwbvlzP3G6VFnNRbsZQIxQ10PbKKHt8gZ/HW/D/747aDl+QkDqg3KQLMQ==

borsh@^0.7.0:
  version "0.7.0"
  resolved "https://registry.yarnpkg.com/borsh/-/borsh-0.7.0.tgz#6e9560d719d86d90dc589bca60ffc8a6c51fec2a"
  integrity sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==
  dependencies:
    bn.js "^5.2.0"
    bs58 "^4.0.0"
    text-encoding-utf-8 "^1.0.2"

brace-expansion@^1.1.7:
  version "1.1.11"
  resolved "https://registry.yarnpkg.com/brace-expansion/-/brace-expansion-1.1.11.tgz#3c7fcbf529d87226f3d2f52b966ff5271eb441dd"
  integrity sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==
  dependencies:
    balanced-match "^1.0.0"
    concat-map "0.0.1"

braces@~3.0.2:
  version "3.0.3"
  resolved "https://registry.yarnpkg.com/braces/-/braces-3.0.3.tgz#490332f40919452272d55a8480adc0c441358789"
  integrity sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==
  dependencies:
    fill-range "^7.1.1"

browser-stdout@1.3.1:
  version "1.3.1"
  resolved "https://registry.yarnpkg.com/browser-stdout/-/browser-stdout-1.3.1.tgz#baa559ee14ced73452229bad7326467c61fabd60"
  integrity sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==

bs58@^4.0.0, bs58@^4.0.1:
  version "4.0.1"
  resolved "https://registry.yarnpkg.com/bs58/-/bs58-4.0.1.tgz#be161e76c354f6f788ae4071f63f34e8c4f0a42a"
  integrity sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==
  dependencies:
    base-x "^3.0.2"

bs58@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/bs58/-/bs58-5.0.0.tgz#865575b4d13c09ea2a84622df6c8cbeb54ffc279"
  integrity sha512-r+ihvQJvahgYT50JD05dyJNKlmmSlMoOGwn1lCcEzanPglg7TxYjioQUYehQ9mAR/+hOSd2jRc/Z2y5UxBymvQ==
  dependencies:
    base-x "^4.0.0"

buffer-from@^1.0.0, buffer-from@^1.1.0:
  version "1.1.2"
  resolved "https://registry.yarnpkg.com/buffer-from/-/buffer-from-1.1.2.tgz#2b146a6fd72e80b4f55d255f35ed59a3a9a41bd5"
  integrity sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==

buffer-layout@^1.2.0, buffer-layout@^1.2.2:
  version "1.2.2"
  resolved "https://registry.yarnpkg.com/buffer-layout/-/buffer-layout-1.2.2.tgz#b9814e7c7235783085f9ca4966a0cfff112259d5"
  integrity sha512-kWSuLN694+KTk8SrYvCqwP2WcgQjoRCiF5b4QDvkkz8EmgD+aWAIceGFKMIAdmF/pH+vpgNV3d3kAKorcdAmWA==

buffer@6.0.3, buffer@^6.0.3, buffer@~6.0.3:
  version "6.0.3"
  resolved "https://registry.yarnpkg.com/buffer/-/buffer-6.0.3.tgz#2ace578459cc8fbe2a70aaa8f52ee63b6a74c6c6"
  integrity sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==
  dependencies:
    base64-js "^1.3.1"
    ieee754 "^1.2.1"

bufferutil@^4.0.1:
  version "4.0.8"
  resolved "https://registry.yarnpkg.com/bufferutil/-/bufferutil-4.0.8.tgz#1de6a71092d65d7766c4d8a522b261a6e787e8ea"
  integrity sha512-4T53u4PdgsXqKaIctwF8ifXlRTTmEPJ8iEPWFdGZvcf7sbwYo6FKFEX9eNNAnzFZ7EzJAQ3CJeOtCRA4rDp7Pw==
  dependencies:
    node-gyp-build "^4.3.0"

camelcase@^6.0.0, camelcase@^6.3.0:
  version "6.3.0"
  resolved "https://registry.yarnpkg.com/camelcase/-/camelcase-6.3.0.tgz#5685b95eb209ac9c0c177467778c9c84df58ba9a"
  integrity sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==

chai@^4.3.4:
  version "4.5.0"
  resolved "https://registry.yarnpkg.com/chai/-/chai-4.5.0.tgz#707e49923afdd9b13a8b0b47d33d732d13812fd8"
  integrity sha512-RITGBfijLkBddZvnn8jdqoTypxvqbOLYQkGGxXzeFjVHvudaPw0HNFD9x928/eUwYWd2dPCugVqspGALTZZQKw==
  dependencies:
    assertion-error "^1.1.0"
    check-error "^1.0.3"
    deep-eql "^4.1.3"
    get-func-name "^2.0.2"
    loupe "^2.3.6"
    pathval "^1.1.1"
    type-detect "^4.1.0"

chalk@^4.1.0:
  version "4.1.2"
  resolved "https://registry.yarnpkg.com/chalk/-/chalk-4.1.2.tgz#aac4e2b7734a740867aeb16bf02aad556a1e7a01"
  integrity sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==
  dependencies:
    ansi-styles "^4.1.0"
    supports-color "^7.1.0"

check-error@^1.0.3:
  version "1.0.3"
  resolved "https://registry.yarnpkg.com/check-error/-/check-error-1.0.3.tgz#a6502e4312a7ee969f646e83bb3ddd56281bd694"
  integrity sha512-iKEoDYaRmd1mxM90a2OEfWhjsjPpYPuQ+lMYsoxB126+t8fw7ySEO48nmDg5COTjxDI65/Y2OWpeEHk3ZOe8zg==
  dependencies:
    get-func-name "^2.0.2"

chokidar@3.5.3:
  version "3.5.3"
  resolved "https://registry.yarnpkg.com/chokidar/-/chokidar-3.5.3.tgz#1cf37c8707b932bd1af1ae22c0432e2acd1903bd"
  integrity sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==
  dependencies:
    anymatch "~3.1.2"
    braces "~3.0.2"
    glob-parent "~5.1.2"
    is-binary-path "~2.1.0"
    is-glob "~4.0.1"
    normalize-path "~3.0.0"
    readdirp "~3.6.0"
  optionalDependencies:
    fsevents "~2.3.2"

cliui@^7.0.2:
  version "7.0.4"
  resolved "https://registry.yarnpkg.com/cliui/-/cliui-7.0.4.tgz#a0265ee655476fc807aea9df3df8df7783808b4f"
  integrity sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==
  dependencies:
    string-width "^4.2.0"
    strip-ansi "^6.0.0"
    wrap-ansi "^7.0.0"

color-convert@^2.0.1:
  version "2.0.1"
  resolved "https://registry.yarnpkg.com/color-convert/-/color-convert-2.0.1.tgz#72d3a68d598c9bdb3af2ad1e84f21d896abd4de3"
  integrity sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==
  dependencies:
    color-name "~1.1.4"

color-name@~1.1.4:
  version "1.1.4"
  resolved "https://registry.yarnpkg.com/color-name/-/color-name-1.1.4.tgz#c2a09a87acbde69543de6f63fa3995c826c536a2"
  integrity sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==

commander@^2.20.3:
  version "2.20.3"
  resolved "https://registry.yarnpkg.com/commander/-/commander-2.20.3.tgz#fd485e84c03eb4881c20722ba48035e8531aeb33"
  integrity sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==

concat-map@0.0.1:
  version "0.0.1"
  resolved "https://registry.yarnpkg.com/concat-map/-/concat-map-0.0.1.tgz#d8a96bd77fd68df7793a73036a3ba0d5405d477b"
  integrity sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==

cross-fetch@^3.1.5:
  version "3.1.8"
  resolved "https://registry.yarnpkg.com/cross-fetch/-/cross-fetch-3.1.8.tgz#0327eba65fd68a7d119f8fb2bf9334a1a7956f82"
  integrity sha512-cvA+JwZoU0Xq+h6WkMvAUqPEYy92Obet6UdKLfW60qn99ftItKjB5T+BkyWOFWe2pUyfQ+IJHmpOTznqk1M6Kg==
  dependencies:
    node-fetch "^2.6.12"

crypto-hash@^1.3.0:
  version "1.3.0"
  resolved "https://registry.yarnpkg.com/crypto-hash/-/crypto-hash-1.3.0.tgz#b402cb08f4529e9f4f09346c3e275942f845e247"
  integrity sha512-lyAZ0EMyjDkVvz8WOeVnuCPvKVBXcMv1l5SVqO1yC7PzTwrD/pPje/BIRbWhMoPe436U+Y2nD7f5bFx0kt+Sbg==

debug@4.3.3:
  version "4.3.3"
  resolved "https://registry.yarnpkg.com/debug/-/debug-4.3.3.tgz#04266e0b70a98d4462e6e288e38259213332b664"
  integrity sha512-/zxw5+vh1Tfv+4Qn7a5nsbcJKPaSvCDhojn6FEl9vupwK2VCSDtEiEtqr8DFtzYFOdz63LBkxec7DYuc2jon6Q==
  dependencies:
    ms "2.1.2"

decamelize@^4.0.0:
  version "4.0.0"
  resolved "https://registry.yarnpkg.com/decamelize/-/decamelize-4.0.0.tgz#aa472d7bf660eb15f3494efd531cab7f2a709837"
  integrity sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==

decimal.js@*, decimal.js@^10.4.3:
  version "10.4.3"
  resolved "https://registry.yarnpkg.com/decimal.js/-/decimal.js-10.4.3.tgz#1044092884d245d1b7f65725fa4ad4c6f781cc23"
  integrity sha512-VBBaLc1MgL5XpzgIP7ny5Z6Nx3UrRkIViUkPUdtl9aya5amy3De1gsUUSB1g3+3sExYNjCAsAznmukyxCb1GRA==

deep-eql@^4.1.3:
  version "4.1.4"
  resolved "https://registry.yarnpkg.com/deep-eql/-/deep-eql-4.1.4.tgz#d0d3912865911bb8fac5afb4e3acfa6a28dc72b7"
  integrity sha512-SUwdGfqdKOwxCPeVYjwSyRpJ7Z+fhpwIAtmCUdZIWZ/YP5R9WAsyuSgpLVDi9bjWoN2LXHNss/dk3urXtdQxGg==
  dependencies:
    type-detect "^4.0.0"

delay@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/delay/-/delay-5.0.0.tgz#137045ef1b96e5071060dd5be60bf9334436bd1d"
  integrity sha512-ReEBKkIfe4ya47wlPYf/gu5ib6yUG0/Aez0JQZQz94kiWtRQvZIQbTiehsnwHvLSWJnQdhVeqYue7Id1dKr0qw==

diff@5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/diff/-/diff-5.0.0.tgz#7ed6ad76d859d030787ec35855f5b1daf31d852b"
  integrity sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==

diff@^3.1.0:
  version "3.5.0"
  resolved "https://registry.yarnpkg.com/diff/-/diff-3.5.0.tgz#800c0dd1e0a8bfbc95835c202ad220fe317e5a12"
  integrity sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA==

dot-case@^3.0.4:
  version "3.0.4"
  resolved "https://registry.yarnpkg.com/dot-case/-/dot-case-3.0.4.tgz#9b2b670d00a431667a8a75ba29cd1b98809ce751"
  integrity sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==
  dependencies:
    no-case "^3.0.4"
    tslib "^2.0.3"

emoji-regex@^8.0.0:
  version "8.0.0"
  resolved "https://registry.yarnpkg.com/emoji-regex/-/emoji-regex-8.0.0.tgz#e818fd69ce5ccfcb404594f842963bf53164cc37"
  integrity sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==

es6-promise@^4.0.3:
  version "4.2.8"
  resolved "https://registry.yarnpkg.com/es6-promise/-/es6-promise-4.2.8.tgz#4eb21594c972bc40553d276e510539143db53e0a"
  integrity sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w==

es6-promisify@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/es6-promisify/-/es6-promisify-5.0.0.tgz#5109d62f3e56ea967c4b63505aef08291c8a5203"
  integrity sha512-C+d6UdsYDk0lMebHNR4S2NybQMMngAOnOwYBQjTOiv0MkoJMP0Myw2mgpDLBcpfCmRLxyFqYhS/CfOENq4SJhQ==
  dependencies:
    es6-promise "^4.0.3"

escalade@^3.1.1:
  version "3.2.0"
  resolved "https://registry.yarnpkg.com/escalade/-/escalade-3.2.0.tgz#011a3f69856ba189dffa7dc8fcce99d2a87903e5"
  integrity sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==

escape-string-regexp@4.0.0:
  version "4.0.0"
  resolved "https://registry.yarnpkg.com/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz#14ba83a5d373e3d311e5afca29cf5bfad965bf34"
  integrity sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==

eventemitter3@^4.0.7:
  version "4.0.7"
  resolved "https://registry.yarnpkg.com/eventemitter3/-/eventemitter3-4.0.7.tgz#2de9b68f6528d5644ef5c59526a1b4a07306169f"
  integrity sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==

eventemitter3@^5.0.1:
  version "5.0.1"
  resolved "https://registry.yarnpkg.com/eventemitter3/-/eventemitter3-5.0.1.tgz#53f5ffd0a492ac800721bb42c66b841de96423c4"
  integrity sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==

eyes@^0.1.8:
  version "0.1.8"
  resolved "https://registry.yarnpkg.com/eyes/-/eyes-0.1.8.tgz#62cf120234c683785d902348a800ef3e0cc20bc0"
  integrity sha512-GipyPsXO1anza0AOZdy69Im7hGFCNB7Y/NGjDlZGJ3GJJLtwNSb2vrzYrTYJRrRloVx7pl+bhUaTB8yiccPvFQ==

fast-stable-stringify@^1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/fast-stable-stringify/-/fast-stable-stringify-1.0.0.tgz#5c5543462b22aeeefd36d05b34e51c78cb86d313"
  integrity sha512-wpYMUmFu5f00Sm0cj2pfivpmawLZ0NKdviQ4w9zJeR8JVtOpOxHmLaJuj0vxvGqMJQWyP/COUkF75/57OKyRag==

file-uri-to-path@1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz#553a7b8446ff6f684359c445f1e37a05dacc33dd"
  integrity sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==

fill-range@^7.1.1:
  version "7.1.1"
  resolved "https://registry.yarnpkg.com/fill-range/-/fill-range-7.1.1.tgz#44265d3cac07e3ea7dc247516380643754a05292"
  integrity sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==
  dependencies:
    to-regex-range "^5.0.1"

find-up@5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/find-up/-/find-up-5.0.0.tgz#4c92819ecb7083561e4f4a240a86be5198f536fc"
  integrity sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==
  dependencies:
    locate-path "^6.0.0"
    path-exists "^4.0.0"

flat@^5.0.2:
  version "5.0.2"
  resolved "https://registry.yarnpkg.com/flat/-/flat-5.0.2.tgz#8ca6fe332069ffa9d324c327198c598259ceb241"
  integrity sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==

fs.realpath@^1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/fs.realpath/-/fs.realpath-1.0.0.tgz#1504ad2523158caa40db4a2787cb01411994ea4f"
  integrity sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==

fsevents@~2.3.2:
  version "2.3.3"
  resolved "https://registry.yarnpkg.com/fsevents/-/fsevents-2.3.3.tgz#cac6407785d03675a2a5e1a5305c697b347d90d6"
  integrity sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==

get-caller-file@^2.0.5:
  version "2.0.5"
  resolved "https://registry.yarnpkg.com/get-caller-file/-/get-caller-file-2.0.5.tgz#4f94412a82db32f36e3b0b9741f8a97feb031f7e"
  integrity sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==

get-func-name@^2.0.1, get-func-name@^2.0.2:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/get-func-name/-/get-func-name-2.0.2.tgz#0d7cf20cd13fda808669ffa88f4ffc7a3943fc41"
  integrity sha512-8vXOvuE167CtIc3OyItco7N/dpRtBbYOsPsXCz7X/PMnlGjYjSGuZJgM1Y7mmew7BKf9BqvLX2tnOVy1BBUsxQ==

glob-parent@~5.1.2:
  version "5.1.2"
  resolved "https://registry.yarnpkg.com/glob-parent/-/glob-parent-5.1.2.tgz#869832c58034fe68a4093c17dc15e8340d8401c4"
  integrity sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==
  dependencies:
    is-glob "^4.0.1"

glob@7.2.0:
  version "7.2.0"
  resolved "https://registry.yarnpkg.com/glob/-/glob-7.2.0.tgz#d15535af7732e02e948f4c41628bd910293f6023"
  integrity sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==
  dependencies:
    fs.realpath "^1.0.0"
    inflight "^1.0.4"
    inherits "2"
    minimatch "^3.0.4"
    once "^1.3.0"
    path-is-absolute "^1.0.0"

growl@1.10.5:
  version "1.10.5"
  resolved "https://registry.yarnpkg.com/growl/-/growl-1.10.5.tgz#f2735dc2283674fa67478b10181059355c369e5e"
  integrity sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==

has-flag@^4.0.0:
  version "4.0.0"
  resolved "https://registry.yarnpkg.com/has-flag/-/has-flag-4.0.0.tgz#944771fd9c81c81265c4d6941860da06bb59479b"
  integrity sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==

he@1.2.0:
  version "1.2.0"
  resolved "https://registry.yarnpkg.com/he/-/he-1.2.0.tgz#84ae65fa7eafb165fddb61566ae14baf05664f0f"
  integrity sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==

humanize-ms@^1.2.1:
  version "1.2.1"
  resolved "https://registry.yarnpkg.com/humanize-ms/-/humanize-ms-1.2.1.tgz#c46e3159a293f6b896da29316d8b6fe8bb79bbed"
  integrity sha512-Fl70vYtsAFb/C06PTS9dZBo7ihau+Tu/DNCk/OyHhea07S+aeMWpFFkUaXRa8fI+ScZbEI8dfSxwY7gxZ9SAVQ==
  dependencies:
    ms "^2.0.0"

ieee754@^1.2.1:
  version "1.2.1"
  resolved "https://registry.yarnpkg.com/ieee754/-/ieee754-1.2.1.tgz#8eb7a10a63fff25d15a57b001586d177d1b0d352"
  integrity sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==

inflight@^1.0.4:
  version "1.0.6"
  resolved "https://registry.yarnpkg.com/inflight/-/inflight-1.0.6.tgz#49bd6331d7d02d0c09bc910a1075ba8165b56df9"
  integrity sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==
  dependencies:
    once "^1.3.0"
    wrappy "1"

inherits@2:
  version "2.0.4"
  resolved "https://registry.yarnpkg.com/inherits/-/inherits-2.0.4.tgz#0fa2c64f932917c3433a0ded55363aae37416b7c"
  integrity sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==

is-binary-path@~2.1.0:
  version "2.1.0"
  resolved "https://registry.yarnpkg.com/is-binary-path/-/is-binary-path-2.1.0.tgz#ea1f7f3b80f064236e83470f86c09c254fb45b09"
  integrity sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==
  dependencies:
    binary-extensions "^2.0.0"

is-extglob@^2.1.1:
  version "2.1.1"
  resolved "https://registry.yarnpkg.com/is-extglob/-/is-extglob-2.1.1.tgz#a88c02535791f02ed37c76a1b9ea9773c833f8c2"
  integrity sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==

is-fullwidth-code-point@^3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz#f116f8064fe90b3f7844a38997c0b75051269f1d"
  integrity sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==

is-glob@^4.0.1, is-glob@~4.0.1:
  version "4.0.3"
  resolved "https://registry.yarnpkg.com/is-glob/-/is-glob-4.0.3.tgz#64f61e42cbbb2eec2071a9dac0b28ba1e65d5084"
  integrity sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==
  dependencies:
    is-extglob "^2.1.1"

is-number@^7.0.0:
  version "7.0.0"
  resolved "https://registry.yarnpkg.com/is-number/-/is-number-7.0.0.tgz#7535345b896734d5f80c4d06c50955527a14f12b"
  integrity sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==

is-plain-obj@^2.1.0:
  version "2.1.0"
  resolved "https://registry.yarnpkg.com/is-plain-obj/-/is-plain-obj-2.1.0.tgz#45e42e37fccf1f40da8e5f76ee21515840c09287"
  integrity sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==

is-unicode-supported@^0.1.0:
  version "0.1.0"
  resolved "https://registry.yarnpkg.com/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz#3f26c76a809593b52bfa2ecb5710ed2779b522a7"
  integrity sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==

isexe@^2.0.0:
  version "2.0.0"
  resolved "https://registry.yarnpkg.com/isexe/-/isexe-2.0.0.tgz#e8fbf374dc556ff8947a10dcb0572d633f2cfa10"
  integrity sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==

isomorphic-ws@^4.0.1:
  version "4.0.1"
  resolved "https://registry.yarnpkg.com/isomorphic-ws/-/isomorphic-ws-4.0.1.tgz#55fd4cd6c5e6491e76dc125938dd863f5cd4f2dc"
  integrity sha512-BhBvN2MBpWTaSHdWRb/bwdZJ1WaehQ2L1KngkCkfLUGF0mAWAT1sQUQacEmQ0jXkFw/czDXPNQSL5u2/Krsz1w==

jayson@^4.1.1:
  version "4.1.2"
  resolved "https://registry.yarnpkg.com/jayson/-/jayson-4.1.2.tgz#443c26a8658703e0b2e881117b09395d88b6982e"
  integrity sha512-5nzMWDHy6f+koZOuYsArh2AXs73NfWYVlFyJJuCedr93GpY+Ku8qq10ropSXVfHK+H0T6paA88ww+/dV+1fBNA==
  dependencies:
    "@types/connect" "^3.4.33"
    "@types/node" "^12.12.54"
    "@types/ws" "^7.4.4"
    JSONStream "^1.3.5"
    commander "^2.20.3"
    delay "^5.0.0"
    es6-promisify "^5.0.0"
    eyes "^0.1.8"
    isomorphic-ws "^4.0.1"
    json-stringify-safe "^5.0.1"
    uuid "^8.3.2"
    ws "^7.5.10"

js-yaml@4.1.0:
  version "4.1.0"
  resolved "https://registry.yarnpkg.com/js-yaml/-/js-yaml-4.1.0.tgz#c1fb65f8f5017901cdd2c951864ba18458a10602"
  integrity sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==
  dependencies:
    argparse "^2.0.1"

json-stringify-safe@^5.0.1:
  version "5.0.1"
  resolved "https://registry.yarnpkg.com/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz#1296a2d58fd45f19a0f6ce01d65701e2c735b6eb"
  integrity sha512-ZClg6AaYvamvYEE82d3Iyd3vSSIjQ+odgjaTzRuO3s7toCdFKczob2i0zCh7JE8kWn17yvAWhUVxvqGwUalsRA==

json5@^1.0.2:
  version "1.0.2"
  resolved "https://registry.yarnpkg.com/json5/-/json5-1.0.2.tgz#63d98d60f21b313b77c4d6da18bfa69d80e1d593"
  integrity sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==
  dependencies:
    minimist "^1.2.0"

jsonparse@^1.2.0:
  version "1.3.1"
  resolved "https://registry.yarnpkg.com/jsonparse/-/jsonparse-1.3.1.tgz#3f4dae4a91fac315f71062f8521cc239f1366280"
  integrity sha512-POQXvpdL69+CluYsillJ7SUhKvytYjW9vG/GKpnf+xP8UWgYEM/RaMzHHofbALDiKbbP1W8UEYmgGl39WkPZsg==

locate-path@^6.0.0:
  version "6.0.0"
  resolved "https://registry.yarnpkg.com/locate-path/-/locate-path-6.0.0.tgz#55321eb309febbc59c4801d931a72452a681d286"
  integrity sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==
  dependencies:
    p-locate "^5.0.0"

log-symbols@4.1.0:
  version "4.1.0"
  resolved "https://registry.yarnpkg.com/log-symbols/-/log-symbols-4.1.0.tgz#3fbdbb95b4683ac9fc785111e792e558d4abd503"
  integrity sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==
  dependencies:
    chalk "^4.1.0"
    is-unicode-supported "^0.1.0"

loupe@^2.3.6:
  version "2.3.7"
  resolved "https://registry.yarnpkg.com/loupe/-/loupe-2.3.7.tgz#6e69b7d4db7d3ab436328013d37d1c8c3540c697"
  integrity sha512-zSMINGVYkdpYSOBmLi0D1Uo7JU9nVdQKrHxC8eYlV+9YKK9WePqAlL7lSlorG/U2Fw1w0hTBmaa/jrQ3UbPHtA==
  dependencies:
    get-func-name "^2.0.1"

lower-case@^2.0.2:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/lower-case/-/lower-case-2.0.2.tgz#6fa237c63dbdc4a82ca0fd882e4722dc5e634e28"
  integrity sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==
  dependencies:
    tslib "^2.0.3"

make-error@^1.1.1:
  version "1.3.6"
  resolved "https://registry.yarnpkg.com/make-error/-/make-error-1.3.6.tgz#2eb2e37ea9b67c4891f684a1394799af484cf7a2"
  integrity sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==

minimatch@4.2.1:
  version "4.2.1"
  resolved "https://registry.yarnpkg.com/minimatch/-/minimatch-4.2.1.tgz#40d9d511a46bdc4e563c22c3080cde9c0d8299b4"
  integrity sha512-9Uq1ChtSZO+Mxa/CL1eGizn2vRn3MlLgzhT0Iz8zaY8NdvxvB0d5QdPFmCKf7JKA9Lerx5vRrnwO03jsSfGG9g==
  dependencies:
    brace-expansion "^1.1.7"

minimatch@^3.0.4:
  version "3.1.2"
  resolved "https://registry.yarnpkg.com/minimatch/-/minimatch-3.1.2.tgz#19cd194bfd3e428f049a70817c038d89ab4be35b"
  integrity sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==
  dependencies:
    brace-expansion "^1.1.7"

minimist@^1.2.0, minimist@^1.2.6:
  version "1.2.8"
  resolved "https://registry.yarnpkg.com/minimist/-/minimist-1.2.8.tgz#c1a464e7693302e082a075cee0c057741ac4772c"
  integrity sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==

mkdirp@^0.5.1:
  version "0.5.6"
  resolved "https://registry.yarnpkg.com/mkdirp/-/mkdirp-0.5.6.tgz#7def03d2432dcae4ba1d611445c48396062255f6"
  integrity sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==
  dependencies:
    minimist "^1.2.6"

mocha@^9.0.3:
  version "9.2.2"
  resolved "https://registry.yarnpkg.com/mocha/-/mocha-9.2.2.tgz#d70db46bdb93ca57402c809333e5a84977a88fb9"
  integrity sha512-L6XC3EdwT6YrIk0yXpavvLkn8h+EU+Y5UcCHKECyMbdUIxyMuZj4bX4U9e1nvnvUUvQVsV2VHQr5zLdcUkhW/g==
  dependencies:
    "@ungap/promise-all-settled" "1.1.2"
    ansi-colors "4.1.1"
    browser-stdout "1.3.1"
    chokidar "3.5.3"
    debug "4.3.3"
    diff "5.0.0"
    escape-string-regexp "4.0.0"
    find-up "5.0.0"
    glob "7.2.0"
    growl "1.10.5"
    he "1.2.0"
    js-yaml "4.1.0"
    log-symbols "4.1.0"
    minimatch "4.2.1"
    ms "2.1.3"
    nanoid "3.3.1"
    serialize-javascript "6.0.0"
    strip-json-comments "3.1.1"
    supports-color "8.1.1"
    which "2.0.2"
    workerpool "6.2.0"
    yargs "16.2.0"
    yargs-parser "20.2.4"
    yargs-unparser "2.0.0"

ms@2.1.2:
  version "2.1.2"
  resolved "https://registry.yarnpkg.com/ms/-/ms-2.1.2.tgz#d09d1f357b443f493382a8eb3ccd183872ae6009"
  integrity sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==

ms@2.1.3, ms@^2.0.0:
  version "2.1.3"
  resolved "https://registry.yarnpkg.com/ms/-/ms-2.1.3.tgz#574c8138ce1d2b5861f0b44579dbadd60c6615b2"
  integrity sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==

nanoid@3.3.1:
  version "3.3.1"
  resolved "https://registry.yarnpkg.com/nanoid/-/nanoid-3.3.1.tgz#6347a18cac88af88f58af0b3594b723d5e99bb35"
  integrity sha512-n6Vs/3KGyxPQd6uO0eH4Bv0ojGSUvuLlIHtC3Y0kEO23YRge8H9x1GCzLn28YX0H66pMkxuaeESFq4tKISKwdw==

no-case@^3.0.4:
  version "3.0.4"
  resolved "https://registry.yarnpkg.com/no-case/-/no-case-3.0.4.tgz#d361fd5c9800f558551a8369fc0dcd4662b6124d"
  integrity sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==
  dependencies:
    lower-case "^2.0.2"
    tslib "^2.0.3"

node-fetch@^2.6.12, node-fetch@^2.7.0:
  version "2.7.0"
  resolved "https://registry.yarnpkg.com/node-fetch/-/node-fetch-2.7.0.tgz#d0f0fa6e3e2dc1d27efcd8ad99d550bda94d187d"
  integrity sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==
  dependencies:
    whatwg-url "^5.0.0"

node-gyp-build@^4.3.0:
  version "4.8.2"
  resolved "https://registry.yarnpkg.com/node-gyp-build/-/node-gyp-build-4.8.2.tgz#4f802b71c1ab2ca16af830e6c1ea7dd1ad9496fa"
  integrity sha512-IRUxE4BVsHWXkV/SFOut4qTlagw2aM8T5/vnTsmrHJvVoKueJHRc/JaFND7QDDc61kLYUJ6qlZM3sqTSyx2dTw==

normalize-path@^3.0.0, normalize-path@~3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/normalize-path/-/normalize-path-3.0.0.tgz#0dcd69ff23a1c9b11fd0978316644a0388216a65"
  integrity sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==

once@^1.3.0:
  version "1.4.0"
  resolved "https://registry.yarnpkg.com/once/-/once-1.4.0.tgz#583b1aa775961d4b113ac17d9c50baef9dd76bd1"
  integrity sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==
  dependencies:
    wrappy "1"

p-limit@^3.0.2:
  version "3.1.0"
  resolved "https://registry.yarnpkg.com/p-limit/-/p-limit-3.1.0.tgz#e1daccbe78d0d1388ca18c64fea38e3e57e3706b"
  integrity sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==
  dependencies:
    yocto-queue "^0.1.0"

p-locate@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/p-locate/-/p-locate-5.0.0.tgz#83c8315c6785005e3bd021839411c9e110e6d834"
  integrity sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==
  dependencies:
    p-limit "^3.0.2"

pako@^2.0.3:
  version "2.1.0"
  resolved "https://registry.yarnpkg.com/pako/-/pako-2.1.0.tgz#266cc37f98c7d883545d11335c00fbd4062c9a86"
  integrity sha512-w+eufiZ1WuJYgPXbV/PO3NCMEc3xqylkKHzp8bxp1uW4qaSNQUkwmLLEc3kKsfz8lpV1F8Ht3U1Cm+9Srog2ug==

path-exists@^4.0.0:
  version "4.0.0"
  resolved "https://registry.yarnpkg.com/path-exists/-/path-exists-4.0.0.tgz#513bdbe2d3b95d7762e8c1137efa195c6c61b5b3"
  integrity sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==

path-is-absolute@^1.0.0:
  version "1.0.1"
  resolved "https://registry.yarnpkg.com/path-is-absolute/-/path-is-absolute-1.0.1.tgz#174b9268735534ffbc7ace6bf53a5a9e1b5c5f5f"
  integrity sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==

pathval@^1.1.1:
  version "1.1.1"
  resolved "https://registry.yarnpkg.com/pathval/-/pathval-1.1.1.tgz#8534e77a77ce7ac5a2512ea21e0fdb8fcf6c3d8d"
  integrity sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==

picomatch@^2.0.4, picomatch@^2.2.1:
  version "2.3.1"
  resolved "https://registry.yarnpkg.com/picomatch/-/picomatch-2.3.1.tgz#3ba3833733646d9d3e4995946c1365a67fb07a42"
  integrity sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==

prettier@^2.6.2:
  version "2.8.8"
  resolved "https://registry.yarnpkg.com/prettier/-/prettier-2.8.8.tgz#e8c5d7e98a4305ffe3de2e1fc4aca1a71c28b1da"
  integrity sha512-tdN8qQGvNjw4CHbY+XXk0JgCXn9QiF21a55rBe5LJAU+kDyC4WQn4+awm2Xfk2lQMk5fKup9XgzTZtGkjBdP9Q==

randombytes@^2.1.0:
  version "2.1.0"
  resolved "https://registry.yarnpkg.com/randombytes/-/randombytes-2.1.0.tgz#df6f84372f0270dc65cdf6291349ab7a473d4f2a"
  integrity sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==
  dependencies:
    safe-buffer "^5.1.0"

readdirp@~3.6.0:
  version "3.6.0"
  resolved "https://registry.yarnpkg.com/readdirp/-/readdirp-3.6.0.tgz#74a370bd857116e245b29cc97340cd431a02a6c7"
  integrity sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==
  dependencies:
    picomatch "^2.2.1"

regenerator-runtime@^0.14.0:
  version "0.14.1"
  resolved "https://registry.yarnpkg.com/regenerator-runtime/-/regenerator-runtime-0.14.1.tgz#356ade10263f685dda125100cd862c1db895327f"
  integrity sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw==

require-directory@^2.1.1:
  version "2.1.1"
  resolved "https://registry.yarnpkg.com/require-directory/-/require-directory-2.1.1.tgz#8c64ad5fd30dab1c976e2344ffe7f792a6a6df42"
  integrity sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==

rpc-websockets@^9.0.2:
  version "9.0.2"
  resolved "https://registry.yarnpkg.com/rpc-websockets/-/rpc-websockets-9.0.2.tgz#4c1568d00b8100f997379a363478f41f8f4b242c"
  integrity sha512-YzggvfItxMY3Lwuax5rC18inhbjJv9Py7JXRHxTIi94JOLrqBsSsUUc5bbl5W6c11tXhdfpDPK0KzBhoGe8jjw==
  dependencies:
    "@swc/helpers" "^0.5.11"
    "@types/uuid" "^8.3.4"
    "@types/ws" "^8.2.2"
    buffer "^6.0.3"
    eventemitter3 "^5.0.1"
    uuid "^8.3.2"
    ws "^8.5.0"
  optionalDependencies:
    bufferutil "^4.0.1"
    utf-8-validate "^5.0.2"

safe-buffer@^5.0.1, safe-buffer@^5.1.0:
  version "5.2.1"
  resolved "https://registry.yarnpkg.com/safe-buffer/-/safe-buffer-5.2.1.tgz#1eaf9fa9bdb1fdd4ec75f58f9cdb4e6b7827eec6"
  integrity sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==

serialize-javascript@6.0.0:
  version "6.0.0"
  resolved "https://registry.yarnpkg.com/serialize-javascript/-/serialize-javascript-6.0.0.tgz#efae5d88f45d7924141da8b5c3a7a7e663fefeb8"
  integrity sha512-Qr3TosvguFt8ePWqsvRfrKyQXIiW+nGbYpy8XK24NQHE83caxWt+mIymTT19DGFbNWNLfEwsrkSmN64lVWB9ag==
  dependencies:
    randombytes "^2.1.0"

snake-case@^3.0.4:
  version "3.0.4"
  resolved "https://registry.yarnpkg.com/snake-case/-/snake-case-3.0.4.tgz#4f2bbd568e9935abdfd593f34c691dadb49c452c"
  integrity sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==
  dependencies:
    dot-case "^3.0.4"
    tslib "^2.0.3"

source-map-support@^0.5.6:
  version "0.5.21"
  resolved "https://registry.yarnpkg.com/source-map-support/-/source-map-support-0.5.21.tgz#04fe7c7f9e1ed2d662233c28cb2b35b9f63f6e4f"
  integrity sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==
  dependencies:
    buffer-from "^1.0.0"
    source-map "^0.6.0"

source-map@^0.6.0:
  version "0.6.1"
  resolved "https://registry.yarnpkg.com/source-map/-/source-map-0.6.1.tgz#74722af32e9614e9c287a8d0bbde48b5e2f1a263"
  integrity sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==

string-width@^4.1.0, string-width@^4.2.0:
  version "4.2.3"
  resolved "https://registry.yarnpkg.com/string-width/-/string-width-4.2.3.tgz#269c7117d27b05ad2e536830a8ec895ef9c6d010"
  integrity sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==
  dependencies:
    emoji-regex "^8.0.0"
    is-fullwidth-code-point "^3.0.0"
    strip-ansi "^6.0.1"

strip-ansi@^6.0.0, strip-ansi@^6.0.1:
  version "6.0.1"
  resolved "https://registry.yarnpkg.com/strip-ansi/-/strip-ansi-6.0.1.tgz#9e26c63d30f53443e9489495b2105d37b67a85d9"
  integrity sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==
  dependencies:
    ansi-regex "^5.0.1"

strip-bom@^3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/strip-bom/-/strip-bom-3.0.0.tgz#2334c18e9c759f7bdd56fdef7e9ae3d588e68ed3"
  integrity sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==

strip-json-comments@3.1.1:
  version "3.1.1"
  resolved "https://registry.yarnpkg.com/strip-json-comments/-/strip-json-comments-3.1.1.tgz#31f1281b3832630434831c310c01cccda8cbe006"
  integrity sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==

superstruct@^0.15.4:
  version "0.15.5"
  resolved "https://registry.yarnpkg.com/superstruct/-/superstruct-0.15.5.tgz#0f0a8d3ce31313f0d84c6096cd4fa1bfdedc9dab"
  integrity sha512-4AOeU+P5UuE/4nOUkmcQdW5y7i9ndt1cQd/3iUe+LTz3RxESf/W/5lg4B74HbDMMv8PHnPnGCQFH45kBcrQYoQ==

superstruct@^2.0.2:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/superstruct/-/superstruct-2.0.2.tgz#3f6d32fbdc11c357deff127d591a39b996300c54"
  integrity sha512-uV+TFRZdXsqXTL2pRvujROjdZQ4RAlBUS5BTh9IGm+jTqQntYThciG/qu57Gs69yjnVUSqdxF9YLmSnpupBW9A==

supports-color@8.1.1:
  version "8.1.1"
  resolved "https://registry.yarnpkg.com/supports-color/-/supports-color-8.1.1.tgz#cd6fc17e28500cff56c1b86c0a7fd4a54a73005c"
  integrity sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==
  dependencies:
    has-flag "^4.0.0"

supports-color@^7.1.0:
  version "7.2.0"
  resolved "https://registry.yarnpkg.com/supports-color/-/supports-color-7.2.0.tgz#1b7dcdcb32b8138801b3e478ba6a51caa89648da"
  integrity sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==
  dependencies:
    has-flag "^4.0.0"

text-encoding-utf-8@^1.0.2:
  version "1.0.2"
  resolved "https://registry.yarnpkg.com/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz#585b62197b0ae437e3c7b5d0af27ac1021e10d13"
  integrity sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg==

"through@>=2.2.7 <3":
  version "2.3.8"
  resolved "https://registry.yarnpkg.com/through/-/through-2.3.8.tgz#0dd4c9ffaabc357960b1b724115d7e0e86a2e1f5"
  integrity sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==

to-regex-range@^5.0.1:
  version "5.0.1"
  resolved "https://registry.yarnpkg.com/to-regex-range/-/to-regex-range-5.0.1.tgz#1648c44aae7c8d988a326018ed72f5b4dd0392e4"
  integrity sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==
  dependencies:
    is-number "^7.0.0"

toml@^3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/toml/-/toml-3.0.0.tgz#342160f1af1904ec9d204d03a5d61222d762c5ee"
  integrity sha512-y/mWCZinnvxjTKYhJ+pYxwD0mRLVvOtdS2Awbgxln6iEnt4rk0yBxeSBHkGJcPucRiG0e55mwWp+g/05rsrd6w==

tr46@~0.0.3:
  version "0.0.3"
  resolved "https://registry.yarnpkg.com/tr46/-/tr46-0.0.3.tgz#8184fd347dac9cdc185992f3a6622e14b9d9ab6a"
  integrity sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==

ts-mocha@^10.0.0:
  version "10.0.0"
  resolved "https://registry.yarnpkg.com/ts-mocha/-/ts-mocha-10.0.0.tgz#41a8d099ac90dbbc64b06976c5025ffaebc53cb9"
  integrity sha512-VRfgDO+iiuJFlNB18tzOfypJ21xn2xbuZyDvJvqpTbWgkAgD17ONGr8t+Tl8rcBtOBdjXp5e/Rk+d39f7XBHRw==
  dependencies:
    ts-node "7.0.1"
  optionalDependencies:
    tsconfig-paths "^3.5.0"

ts-node@7.0.1:
  version "7.0.1"
  resolved "https://registry.yarnpkg.com/ts-node/-/ts-node-7.0.1.tgz#9562dc2d1e6d248d24bc55f773e3f614337d9baf"
  integrity sha512-BVwVbPJRspzNh2yfslyT1PSbl5uIk03EZlb493RKHN4qej/D06n1cEhjlOJG69oFsE7OT8XjpTUcYf6pKTLMhw==
  dependencies:
    arrify "^1.0.0"
    buffer-from "^1.1.0"
    diff "^3.1.0"
    make-error "^1.1.1"
    minimist "^1.2.0"
    mkdirp "^0.5.1"
    source-map-support "^0.5.6"
    yn "^2.0.0"

tsconfig-paths@^3.5.0:
  version "3.15.0"
  resolved "https://registry.yarnpkg.com/tsconfig-paths/-/tsconfig-paths-3.15.0.tgz#5299ec605e55b1abb23ec939ef15edaf483070d4"
  integrity sha512-2Ac2RgzDe/cn48GvOe3M+o82pEFewD3UPbyoUHHdKasHwJKjds4fLXWf/Ux5kATBKN20oaFGu+jbElp1pos0mg==
  dependencies:
    "@types/json5" "^0.0.29"
    json5 "^1.0.2"
    minimist "^1.2.6"
    strip-bom "^3.0.0"

tslib@^2.0.3, tslib@^2.4.0:
  version "2.7.0"
  resolved "https://registry.yarnpkg.com/tslib/-/tslib-2.7.0.tgz#d9b40c5c40ab59e8738f297df3087bf1a2690c01"
  integrity sha512-gLXCKdN1/j47AiHiOkJN69hJmcbGTHI0ImLmbYLHykhgeN0jVGola9yVjFgzCUklsZQMW55o+dW7IXv3RCXDzA==

type-detect@^4.0.0, type-detect@^4.1.0:
  version "4.1.0"
  resolved "https://registry.yarnpkg.com/type-detect/-/type-detect-4.1.0.tgz#deb2453e8f08dcae7ae98c626b13dddb0155906c"
  integrity sha512-Acylog8/luQ8L7il+geoSxhEkazvkslg7PSNKOX59mbB9cOveP5aq9h74Y7YU8yDpJwetzQQrfIwtf4Wp4LKcw==

typescript@^4.3.5:
  version "4.9.5"
  resolved "https://registry.yarnpkg.com/typescript/-/typescript-4.9.5.tgz#095979f9bcc0d09da324d58d03ce8f8374cbe65a"
  integrity sha512-1FXk9E2Hm+QzZQ7z+McJiHL4NW1F2EzMu9Nq9i3zAaGqibafqYwCVU6WyWAuyQRRzOlxou8xZSyXLEN8oKj24g==

undici-types@~6.19.2:
  version "6.19.8"
  resolved "https://registry.yarnpkg.com/undici-types/-/undici-types-6.19.8.tgz#35111c9d1437ab83a7cdc0abae2f26d88eda0a02"
  integrity sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==

utf-8-validate@^5.0.2:
  version "5.0.10"
  resolved "https://registry.yarnpkg.com/utf-8-validate/-/utf-8-validate-5.0.10.tgz#d7d10ea39318171ca982718b6b96a8d2442571a2"
  integrity sha512-Z6czzLq4u8fPOyx7TU6X3dvUZVvoJmxSQ+IcrlmagKhilxlhZgxPK6C5Jqbkw1IDUmFTM+cz9QDnnLTwDz/2gQ==
  dependencies:
    node-gyp-build "^4.3.0"

uuid@^8.3.2:
  version "8.3.2"
  resolved "https://registry.yarnpkg.com/uuid/-/uuid-8.3.2.tgz#80d5b5ced271bb9af6c445f21a1a04c606cefbe2"
  integrity sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==

webidl-conversions@^3.0.0:
  version "3.0.1"
  resolved "https://registry.yarnpkg.com/webidl-conversions/-/webidl-conversions-3.0.1.tgz#24534275e2a7bc6be7bc86611cc16ae0a5654871"
  integrity sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==

whatwg-url@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/whatwg-url/-/whatwg-url-5.0.0.tgz#966454e8765462e37644d3626f6742ce8b70965d"
  integrity sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==
  dependencies:
    tr46 "~0.0.3"
    webidl-conversions "^3.0.0"

which@2.0.2:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/which/-/which-2.0.2.tgz#7c6a8dd0a636a0327e10b59c9286eee93f3f51b1"
  integrity sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==
  dependencies:
    isexe "^2.0.0"

workerpool@6.2.0:
  version "6.2.0"
  resolved "https://registry.yarnpkg.com/workerpool/-/workerpool-6.2.0.tgz#827d93c9ba23ee2019c3ffaff5c27fccea289e8b"
  integrity sha512-Rsk5qQHJ9eowMH28Jwhe8HEbmdYDX4lwoMWshiCXugjtHqMD9ZbiqSDLxcsfdqsETPzVUtX5s1Z5kStiIM6l4A==

wrap-ansi@^7.0.0:
  version "7.0.0"
  resolved "https://registry.yarnpkg.com/wrap-ansi/-/wrap-ansi-7.0.0.tgz#67e145cff510a6a6984bdf1152911d69d2eb9e43"
  integrity sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==
  dependencies:
    ansi-styles "^4.0.0"
    string-width "^4.1.0"
    strip-ansi "^6.0.0"

wrappy@1:
  version "1.0.2"
  resolved "https://registry.yarnpkg.com/wrappy/-/wrappy-1.0.2.tgz#b5243d8f3ec1aa35f1364605bc0d1036e30ab69f"
  integrity sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==

ws@^7.5.10:
  version "7.5.10"
  resolved "https://registry.yarnpkg.com/ws/-/ws-7.5.10.tgz#58b5c20dc281633f6c19113f39b349bd8bd558d9"
  integrity sha512-+dbF1tHwZpXcbOJdVOkzLDxZP1ailvSxM6ZweXTegylPny803bFhA+vqBYw4s31NSAk4S2Qz+AKXK9a4wkdjcQ==

ws@^8.5.0:
  version "8.18.0"
  resolved "https://registry.yarnpkg.com/ws/-/ws-8.18.0.tgz#0d7505a6eafe2b0e712d232b42279f53bc289bbc"
  integrity sha512-8VbfWfHLbbwu3+N6OKsOMpBdT4kXPDDB9cJk2bJ6mh9ucxdlnNvH1e+roYkKmN9Nxw2yjz7VzeO9oOz2zJ04Pw==

y18n@^5.0.5:
  version "5.0.8"
  resolved "https://registry.yarnpkg.com/y18n/-/y18n-5.0.8.tgz#7f4934d0f7ca8c56f95314939ddcd2dd91ce1d55"
  integrity sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==

yargs-parser@20.2.4:
  version "20.2.4"
  resolved "https://registry.yarnpkg.com/yargs-parser/-/yargs-parser-20.2.4.tgz#b42890f14566796f85ae8e3a25290d205f154a54"
  integrity sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==

yargs-parser@^20.2.2:
  version "20.2.9"
  resolved "https://registry.yarnpkg.com/yargs-parser/-/yargs-parser-20.2.9.tgz#2eb7dc3b0289718fc295f362753845c41a0c94ee"
  integrity sha512-y11nGElTIV+CT3Zv9t7VKl+Q3hTQoT9a1Qzezhhl6Rp21gJ/IVTW7Z3y9EWXhuUBC2Shnf+DX0antecpAwSP8w==

yargs-unparser@2.0.0:
  version "2.0.0"
  resolved "https://registry.yarnpkg.com/yargs-unparser/-/yargs-unparser-2.0.0.tgz#f131f9226911ae5d9ad38c432fe809366c2325eb"
  integrity sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==
  dependencies:
    camelcase "^6.0.0"
    decamelize "^4.0.0"
    flat "^5.0.2"
    is-plain-obj "^2.1.0"

yargs@16.2.0:
  version "16.2.0"
  resolved "https://registry.yarnpkg.com/yargs/-/yargs-16.2.0.tgz#1c82bf0f6b6a66eafce7ef30e376f49a12477f66"
  integrity sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==
  dependencies:
    cliui "^7.0.2"
    escalade "^3.1.1"
    get-caller-file "^2.0.5"
    require-directory "^2.1.1"
    string-width "^4.2.0"
    y18n "^5.0.5"
    yargs-parser "^20.2.2"

yn@^2.0.0:
  version "2.0.0"
  resolved "https://registry.yarnpkg.com/yn/-/yn-2.0.0.tgz#e5adabc8acf408f6385fc76495684c88e6af689a"
  integrity sha512-uTv8J/wiWTgUTg+9vLTi//leUl5vDQS6uii/emeTb2ssY7vl6QWf2fFbIIGjnhjvbdKlU0ed7QPgY1htTC86jQ==

yocto-queue@^0.1.0:
  version "0.1.0"
  resolved "https://registry.yarnpkg.com/yocto-queue/-/yocto-queue-0.1.0.tgz#0294eb3dee05028d31ee1a5fa2c556a6aaf10a1b"
  integrity sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==


---
./Anchor.toml
---
[toolchain]
anchor_version = "0.30.1"
solana_version = "1.18.15"

[features]
resolution = false
skip-lint = false

[programs.localnet]
solana_pastel_oracle_program = "AfP1c4sFcY1FeiGjQEtyxCim8BRnw22okNbKAsH2sBsB"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "Localnet"
wallet = "~/.config/solana/id.json"

[scripts]
# build = "RUSTUP_TOOLCHAIN=nightly cargo build --release"
test = "sh scripts/run_tests_with_logs.sh"



---
./Cargo.toml
---
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1


---
./testContributor.ts
---
import * as anchor from '@coral-xyz/anchor';
import { SolanaPastelOracleProgram } from './target/types/solana_pastel_oracle_program';
import IDL from './target/idl/solana_pastel_oracle_program.json';
import { web3 } from '@coral-xyz/anchor';

async function main() {
    // Set the provider URL directly
    const providerUrl = "http://127.0.0.1:8899"; // Or use another cluster URL
    const connection = new anchor.web3.Connection(providerUrl, "processed");

    const wallet = new anchor.Wallet(anchor.web3.Keypair.generate());
    const provider = new anchor.AnchorProvider(connection, wallet, { preflightCommitment: "processed" });
    anchor.setProvider(provider);

    const program = new anchor.Program<SolanaPastelOracleProgram>(IDL as any, provider);

    // Keypairs for necessary accounts
    const admin = web3.Keypair.generate();
    const oracleContractState = web3.Keypair.generate();
    const rewardPoolAccount = web3.Keypair.generate();
    const feeReceivingContractAccount = web3.Keypair.generate();
    const newContributor = web3.Keypair.generate();

    // Initialize the Oracle Contract State
    await program.methods.initialize(admin.publicKey)
        .accountsStrict({
            oracleContractState: oracleContractState.publicKey,
            user: admin.publicKey,
            rewardPoolAccount: rewardPoolAccount.publicKey,
            feeReceivingContractAccount: feeReceivingContractAccount.publicKey,
            systemProgram: web3.SystemProgram.programId,
        })
        .signers([admin, oracleContractState, rewardPoolAccount, feeReceivingContractAccount])
        .rpc();

    // Register a new contributor
    await program.methods.registerNewDataContributor()
        .accountsStrict({
            oracleContractState: oracleContractState.publicKey,
            contributorAccount: newContributor.publicKey,
            rewardPoolAccount: rewardPoolAccount.publicKey,
            feeReceivingContractAccount: feeReceivingContractAccount.publicKey,
        })
        .signers([newContributor])
        .rpc();

    // Fetch Contributor data
    const contributorData = await program.contributor.fetch(newContributor.publicKey);

    console.log("Contributor data:", contributorData);
}

main().then(() => process.exit(0)).catch(error => {
    console.error(error);
    process.exit(1);
});


---
./tsconfig.json
---
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "resolveJsonModule": true
  }
}


---
./package.json
---
{
    "scripts": {
        "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
        "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
    },
    "dependencies": {
        "@coral-xyz/anchor": "^0.30.1",
        "@solana/web3.js": "^1.88.0",
        "bs58": "^5.0.0",
        "decimal.js": "^10.4.3"
    },
    "devDependencies": {
        "@types/bn.js": "^5.1.0",
        "@types/chai": "^4.3.0",
        "@types/decimal.js": "^7.4.0",
        "@types/mocha": "^9.0.0",
        "chai": "^4.3.4",
        "mocha": "^9.0.3",
        "prettier": "^2.6.2",
        "ts-mocha": "^10.0.0",
        "typescript": "^4.3.5"
    },
    "license": "MIT"
}


---
./tests/solana_pastel_oracle_program.ts
---
import { assert, expect } from "chai";
import Decimal from "decimal.js";
import * as crypto from "crypto";
import * as anchor from "@coral-xyz/anchor";
import { Program, web3, AnchorProvider, BN } from "@coral-xyz/anchor";
import { ComputeBudgetProgram, SystemProgram } from "@solana/web3.js";
import { SolanaPastelOracleProgram } from "../target/types/solana_pastel_oracle_program";
import IDL from "../target/idl/solana_pastel_oracle_program.json";

const TURN_ON_STORAGE_AND_COMPUTE_PROFILING = true; // Set this flag to true to enable profiling
process.env.ANCHOR_PROVIDER_URL = "http://127.0.0.1:8899";
process.env.RUST_LOG =
  "solana_runtime::system_instruction_processor=trace,solana_runtime::message_processor=trace,solana_bpf_loader=debug,solana_rbpf=debug";
const provider = AnchorProvider.env();
anchor.setProvider(provider);
const program = new Program<SolanaPastelOracleProgram>(IDL as any, provider);
const admin = provider.wallet; // Use the provider's wallet
const oracleContractState = web3.Keypair.generate();
let contributors = []; // Array to store contributor keypairs
let trackedTxids = []; // Initialize an empty array to track TXIDs

const maxSize = 100 * 1024; // 200KB (max size of the oracle contract state account)

const NUM_CONTRIBUTORS = 12;
const NUMBER_OF_SIMULATED_REPORTS = 20;

const REGISTRATION_ENTRANCE_FEE_SOL = 0.1;
const COST_IN_SOL_OF_ADDING_PASTEL_TXID_FOR_MONITORING = 0.0001;
const MIN_NUMBER_OF_ORACLES = 8;
const MIN_REPORTS_FOR_REWARD = 10;
const BAD_CONTRIBUTOR_INDEX = 5; // Define a constant to represent the index at which contributors start submitting incorrect reports with increasing probability
const MIN_COMPLIANCE_SCORE_FOR_REWARD = new BN(65_000000000);
const MIN_RELIABILITY_SCORE_FOR_REWARD = new BN(80_000000000);
const BASE_REWARD_AMOUNT_IN_LAMPORTS = 100000;

const TxidStatusEnum = {
  Invalid: "invalid",
  PendingMining: "pendingMining",
  MinedPendingActivation: "minedPendingActivation",
  MinedActivated: "minedActivated",
};

const PastelTicketTypeEnum = {
  Sense: "sense",
  Cascade: "cascade",
  Nft: "nft",
  InferenceApi: "inferenceApi",
};

let totalComputeUnitsUsed = 0;
let maxAccountStorageUsed = 0;

console.log("Program ID:", program.programId.toString());
console.log("Admin ID:", admin.publicKey.toString());

const measureComputeUnitsAndStorage = async (txSignature: string) => {
  if (!TURN_ON_STORAGE_AND_COMPUTE_PROFILING) return;

  // Retry logic to handle cases where the transaction might not be immediately available
  for (let attempts = 0; attempts < 5; attempts++) {
    const txDetails = await provider.connection.getParsedTransaction(
      txSignature,
      { commitment: "confirmed" }
    );
    if (txDetails) {
      if (txDetails.meta && txDetails.meta.computeUnitsConsumed) {
        totalComputeUnitsUsed += txDetails.meta.computeUnitsConsumed;
      }

      const accounts = txDetails.transaction.message.accountKeys.map(
        (key) => new web3.PublicKey(key.pubkey)
      );
      for (const account of accounts) {
        const accountInfo = await provider.connection.getAccountInfo(account);
        if (accountInfo && accountInfo.data.length > maxAccountStorageUsed) {
          maxAccountStorageUsed = accountInfo.data.length;
        }
      }
      return; // Exit if transaction details are successfully processed
    }
    // Wait a bit before retrying
    await new Promise((resolve) => setTimeout(resolve, 250));
  }
  console.error(
    `Failed to fetch transaction details for signature: ${txSignature}`
  );
};

describe("Initialization", () => {
  it("Initializes and expands the oracle contract state", async () => {
    // Find the PDAs for the RewardPoolAccount and FeeReceivingContractAccount
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );
    const [feeReceivingContractAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("fee_receiving_contract")],
        program.programId
      );

    // Find the PDA for the ContributorDataAccount
    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    // Find the PDA for the TxidSubmissionCountsAccount
    const [txidSubmissionCountsAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("txid_submission_counts")],
        program.programId
      );

    // Find the PDA for the AggregatedConsensusDataAccount
    const [aggregatedConsensusDataAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("aggregated_consensus_data")],
        program.programId
      );

    // Find the PDA for the TempTxStatusReportAccount
    const [tempReportAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("temp_tx_status_report")],
      program.programId
    );

    // Calculate the rent-exempt minimum balance for the account size
    const minBalanceForRentExemption =
      await provider.connection.getMinimumBalanceForRentExemption(100 * 1024); // 100KB
    console.log(
      "Minimum Balance for Rent Exemption:",
      minBalanceForRentExemption
    );

    // Fund the oracleContractState account with enough SOL for rent exemption
    console.log("Funding Oracle Contract State account for rent exemption");
    const fundTx = new anchor.web3.Transaction().add(
      anchor.web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: oracleContractState.publicKey,
        lamports: minBalanceForRentExemption,
      })
    );
    await provider.sendAndConfirm(fundTx);
    const fundTxSignature = await provider.sendAndConfirm(fundTx);
    await measureComputeUnitsAndStorage(fundTxSignature);

    // Initial Initialization
    console.log("Initializing Oracle Contract State");
    const initTxSignature = await program.methods
      .initialize()
      .accountsStrict({
        oracleContractState: oracleContractState.publicKey,
        contributorDataAccount: contributorDataAccountPDA,
        user: admin.publicKey,
        tempReportAccount: tempReportAccountPDA,
        txidSubmissionCountsAccount: txidSubmissionCountsAccountPDA,
        aggregatedConsensusDataAccount: aggregatedConsensusDataAccountPDA,
        systemProgram: web3.SystemProgram.programId,
      })
      .signers([oracleContractState])
      .rpc();
    await measureComputeUnitsAndStorage(initTxSignature);

    let state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );
    assert.ok(
      state.isInitialized,
      "Oracle Contract State should be initialized after first init"
    );
    assert.equal(
      state.adminPubkey.toString(),
      admin.publicKey.toString(),
      "Admin public key should match after first init"
    );

    // Incremental Reallocation
    let currentSize = 10_240; // Initial size after first init

    while (currentSize < maxSize) {
      console.log(
        `Expanding Oracle Contract State size from ${currentSize} to ${
          currentSize + 10_240
        }`
      );
      const reallocateTxSignature = await program.methods
        .reallocateOracleState()
        .accountsStrict({
          oracleContractState: oracleContractState.publicKey,
          adminPubkey: admin.publicKey,
          tempReportAccount: tempReportAccountPDA,
          contributorDataAccount: contributorDataAccountPDA,
          txidSubmissionCountsAccount: txidSubmissionCountsAccountPDA,
          aggregatedConsensusDataAccount: aggregatedConsensusDataAccountPDA,
          systemProgram: web3.SystemProgram.programId,
        })
        .rpc();
      await measureComputeUnitsAndStorage(reallocateTxSignature);

      currentSize += 10_240;
      state = await program.account.oracleContractState.fetch(
        oracleContractState.publicKey
      );

      // Log the updated size of the account
      console.log(`Oracle Contract State size after expansion: ${currentSize}`);
    }

    // Final Assertions
    assert.equal(
      currentSize,
      maxSize,
      "Oracle Contract State should reach the maximum size"
    );
    console.log(
      "Oracle Contract State expanded to the maximum size successfully"
    );
  });
});

describe("Reinitialization Prevention", () => {
  it("Prevents reinitialization of OracleContractState and all PDAs", async () => {
    // Find all PDAs required for initialization
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );
    const [feeReceivingContractAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("fee_receiving_contract")],
      program.programId
    );
    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );
    const [txidSubmissionCountsAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("txid_submission_counts")],
      program.programId
    );
    const [aggregatedConsensusDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("aggregated_consensus_data")],
      program.programId
    );
    const [tempReportAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("temp_tx_status_report")],
      program.programId
    );

    try {
      // Calculate the rent-exempt minimum balance for the account size
      const minBalanceForRentExemption = await provider.connection.getMinimumBalanceForRentExemption(100 * 1024); // 100KB
      
      // Fund the oracleContractState account with enough SOL for rent exemption
      const fundTx = new anchor.web3.Transaction().add(
        anchor.web3.SystemProgram.transfer({
          fromPubkey: admin.publicKey,
          toPubkey: oracleContractState.publicKey,
          lamports: minBalanceForRentExemption,
        })
      );
      await provider.sendAndConfirm(fundTx);

      // Attempt to reinitialize all accounts
      const reinitTxSignature = await program.methods
        .initialize()
        .accountsStrict({
          oracleContractState: oracleContractState.publicKey,
          contributorDataAccount: contributorDataAccountPDA,
          user: admin.publicKey,
          tempReportAccount: tempReportAccountPDA,
          txidSubmissionCountsAccount: txidSubmissionCountsAccountPDA,
          aggregatedConsensusDataAccount: aggregatedConsensusDataAccountPDA,
          systemProgram: web3.SystemProgram.programId,
        })
        .signers([oracleContractState])
        .rpc();

      await measureComputeUnitsAndStorage(reinitTxSignature);
      throw new Error("Reinitialization of OracleContractState and PDAs should fail");
    } catch (error) {
      if (error instanceof anchor.AnchorError) {
        const anchorError = error as anchor.AnchorError;
        assert.equal(
          anchorError.error.errorCode.code,
          "AccountAlreadyInitialized",
          "Should throw AccountAlreadyInitialized error"
        );
        console.log("Successfully prevented reinitialization with correct error:", anchorError.error.errorMessage);
      } else if (error.toString().includes("failed to send transaction")) {
        // Handle case where transaction fails to send due to simulation error
        console.log("Transaction simulation failed as expected due to initialization prevention");
      } else if (error.logs && error.logs.some(log => 
        log.includes("AccountAlreadyInitialized") || 
        log.includes("already in use")
      )) {
        console.log("Successfully prevented reinitialization");
      } else {
        console.error("Unexpected error:", error);
        throw error;
      }
    }

    // Verify that the original initialization state remains unchanged
    const state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );
    
    assert.ok(
      state.isInitialized,
      "Oracle Contract State should still be initialized"
    );
    assert.equal(
      state.adminPubkey.toString(),
      admin.publicKey.toString(),
      "Admin public key should remain unchanged"
    );

    // Log test completion
    console.log("Reinitialization prevention test completed successfully");
  });
});

describe("Set Bridge Contract", () => {
  it("Sets the bridge contract address to admin address", async () => {
    const setBridgeTxSignature = await program.methods
      .setBridgeContract(admin.publicKey)
      .accountsPartial({
        oracleContractState: oracleContractState.publicKey,
        adminPubkey: admin.publicKey,
      })
      .rpc();
    await measureComputeUnitsAndStorage(setBridgeTxSignature);

    // Fetch the updated state to verify the bridge contract address
    const state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );

    // Assertions
    assert.strictEqual(
      state.bridgeContractPubkey.toString(),
      admin.publicKey.toString(),
      "The bridge contract pubkey should be set to the admin address"
    );
    console.log("Bridge contract address set to admin address");
  });
});

describe("Admin Access Control", () => {
  it("Prevents non-admin users from performing admin actions", async () => {
    // Generate an unauthorized user
    const unauthorizedAdmin = web3.Keypair.generate();

    // Find PDAs once to avoid repetition
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );
    const [feeReceivingContractAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("fee_receiving_contract")],
      program.programId
    );

    console.log("Funding unauthorized admin account...");
    // Fund the unauthorized admin with enough SOL for transactions
    const fundTx = new web3.Transaction().add(
      web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: unauthorizedAdmin.publicKey,
        lamports: 1 * web3.LAMPORTS_PER_SOL,
      })
    );

    const fundTxSignature = await provider.sendAndConfirm(fundTx);
    await measureComputeUnitsAndStorage(fundTxSignature);
    console.log(
      `Funded unauthorized admin account: ${unauthorizedAdmin.publicKey.toBase58()}`
    );

    // Test 1: Attempt to set bridge contract as unauthorized user
    console.log("Testing unauthorized bridge contract setting...");
    try {
      const newBridgePubkey = web3.Keypair.generate().publicKey;
      const setBridgeTxSignature = await program.methods
        .setBridgeContract(newBridgePubkey)
        .accountsStrict({
          oracleContractState: oracleContractState.publicKey,
          adminPubkey: unauthorizedAdmin.publicKey,
        })
        .signers([unauthorizedAdmin])
        .rpc();
      
      await measureComputeUnitsAndStorage(setBridgeTxSignature);
      assert.fail("Setting bridge contract should have failed for unauthorized admin");
    } catch (error) {
      const anchorError = anchor.AnchorError.parse(error.logs);
      if (anchorError) {
        assert.equal(
          anchorError.error.errorCode.code,
          "UnauthorizedWithdrawalAccount",
          "Should throw UnauthorizedWithdrawalAccount error when non-admin sets bridge contract"
        );
        console.log("Unauthorized bridge contract setting was correctly rejected");
      } else {
        throw error;
      }
    }

    // Test 2: Attempt to withdraw funds as unauthorized user
    console.log("Testing unauthorized withdrawal...");
    try {
      const withdrawTxSignature = await program.methods
        .withdrawFunds(new BN(1000), new BN(1000))
        .accountsStrict({
          oracleContractState: oracleContractState.publicKey,
          adminAccount: unauthorizedAdmin.publicKey,
          rewardPoolAccount: rewardPoolAccountPDA,
          feeReceivingContractAccount: feeReceivingContractAccountPDA,
          systemProgram: web3.SystemProgram.programId,
        })
        .signers([unauthorizedAdmin])
        .rpc();
      
      await measureComputeUnitsAndStorage(withdrawTxSignature);
      assert.fail("Withdrawal should have failed for unauthorized admin");
    } catch (error) {
      const anchorError = anchor.AnchorError.parse(error.logs);
      if (anchorError) {
        assert.equal(
          anchorError.error.errorCode.code,
          "UnauthorizedWithdrawalAccount",
          "Should throw UnauthorizedWithdrawalAccount error when non-admin withdraws funds"
        );
        console.log("Unauthorized withdrawal was correctly rejected");
      } else {
        throw error;
      }
    }

    // Test 3: Verify that admin access hasn't been compromised
    console.log("Verifying admin access remains intact...");
    const state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );
    assert.ok(
      state.adminPubkey.equals(admin.publicKey),
      "Admin pubkey should remain unchanged after unauthorized attempts"
    );
    console.log("Admin access verification completed successfully");
  });
});

describe("Fee Handling Verification", () => {
  it("Ensures correct transfer of registration fees upon contributor registration", async () => {
    // Find PDAs for fee receiving and reward pool accounts
    const [feeReceivingContractAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("fee_receiving_contract")],
      program.programId
    );
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );
    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    // Generate a new contributor keypair
    const feeContributor = web3.Keypair.generate();
    console.log("Test contributor address:", feeContributor.publicKey.toBase58());

    // Fund the contributor with some SOL for transaction fees
    const fundingTx = new web3.Transaction().add(
      web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: feeContributor.publicKey,
        lamports: 0.1 * web3.LAMPORTS_PER_SOL, // 0.1 SOL for transaction fees
      })
    );
    const fundingTxSignature = await provider.sendAndConfirm(fundingTx);
    await measureComputeUnitsAndStorage(fundingTxSignature);

    // Record balances before any registration-related transfers
    const initialFeeReceivingBalance = await provider.connection.getBalance(
      feeReceivingContractAccountPDA
    );
    const initialRewardPoolBalance = await provider.connection.getBalance(
      rewardPoolAccountPDA
    );

    console.log("Initial fee receiving balance:", initialFeeReceivingBalance);
    console.log("Initial reward pool balance:", initialRewardPoolBalance);

    // Transfer the registration fee to the fee receiving contract
    const registrationFeeInLamports = REGISTRATION_ENTRANCE_FEE_SOL * web3.LAMPORTS_PER_SOL;
    const feeTx = new web3.Transaction().add(
      web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: feeReceivingContractAccountPDA,
        lamports: registrationFeeInLamports,
      })
    );
    const feeTxSignature = await provider.sendAndConfirm(feeTx);
    await measureComputeUnitsAndStorage(feeTxSignature);

    // Record intermediate balances after fee transfer but before registration
    const intermediateFeeReceivingBalance = await provider.connection.getBalance(
      feeReceivingContractAccountPDA
    );
    console.log("Intermediate fee receiving balance:", intermediateFeeReceivingBalance);

    // Register the contributor
    const registerTxSignature = await program.methods
      .registerNewDataContributor()
      .accountsStrict({
        contributorDataAccount: contributorDataAccountPDA,
        contributorAccount: feeContributor.publicKey,
        rewardPoolAccount: rewardPoolAccountPDA,
        feeReceivingContractAccount: feeReceivingContractAccountPDA,
        systemProgram: SystemProgram.programId,
      })
      .signers([feeContributor])
      .rpc();
    await measureComputeUnitsAndStorage(registerTxSignature);

    // Allow some time for the network to process the transaction
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Fetch final balances
    const finalFeeReceivingBalance = await provider.connection.getBalance(
      feeReceivingContractAccountPDA
    );
    const finalRewardPoolBalance = await provider.connection.getBalance(
      rewardPoolAccountPDA
    );

    console.log("Final fee receiving balance:", finalFeeReceivingBalance);
    console.log("Final reward pool balance:", finalRewardPoolBalance);

    // Define an acceptable margin for balance comparisons (0.001 SOL)
    const margin = 1_000_000;

    // Verify that 90% of the registration fee was transferred to the reward pool
    // and 10% remained in the fee receiving contract
    const expectedRewardPoolIncrease = registrationFeeInLamports * 0.1; // 10% of registration fee
    const expectedFeeReceivingBalance = registrationFeeInLamports * 0.9; // 90% of registration fee

    assert.approximately(
      finalFeeReceivingBalance,
      expectedFeeReceivingBalance,
      margin,
      "Fee receiving contract should retain 90% of the registration fee"
    );

    assert.approximately(
      finalRewardPoolBalance - initialRewardPoolBalance,
      expectedRewardPoolIncrease,
      margin,
      "Reward pool should increase by 10% of the registration fee"
    );

    // Verify the contributor was actually registered
    const contributorData = await program.account.contributorDataAccount.fetch(
      contributorDataAccountPDA
    );
    const registeredContributor = contributorData.contributors.find(
      (c) => c.rewardAddress.toBase58() === feeContributor.publicKey.toBase58()
    );
    assert(registeredContributor, "Contributor should be registered in the ContributorDataAccount");
    
    // Log final registration details
    console.log("Registration verification complete:");
    console.log("Total fee receiving balance change:", finalFeeReceivingBalance - initialFeeReceivingBalance);
    console.log("Total reward pool balance change:", finalRewardPoolBalance - initialRewardPoolBalance);
    console.log("Expected fee receiving balance:", expectedFeeReceivingBalance);
    console.log("Expected reward pool increase:", expectedRewardPoolIncrease);
  });
});

describe("Contributor Registration", () => {
  it("Registers new data contributors", async () => {
    // Find the PDAs for the RewardPoolAccount and FeeReceivingContractAccount
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );
    const [feeReceivingContractAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("fee_receiving_contract")],
        program.programId
      );

    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    for (let i = 0; i < NUM_CONTRIBUTORS; i++) {
      // Generate a new keypair for each contributor
      const contributor = web3.Keypair.generate();

      // Transfer the registration fee to feeReceivingContractAccount PDA
      const transaction = new web3.Transaction().add(
        web3.SystemProgram.transfer({
          fromPubkey: admin.publicKey,
          toPubkey: feeReceivingContractAccountPDA,
          lamports: REGISTRATION_ENTRANCE_FEE_SOL * web3.LAMPORTS_PER_SOL,
        })
      );

      // Sign and send the transaction
      const transferTxSignature = await provider.sendAndConfirm(transaction);
      await measureComputeUnitsAndStorage(transferTxSignature);

      // Call the RPC method to register the new data contributor
      const registerTxSignature = await program.methods
        .registerNewDataContributor()
        .accountsPartial({
          contributorDataAccount: contributorDataAccountPDA,
          contributorAccount: contributor.publicKey,
          rewardPoolAccount: rewardPoolAccountPDA,
          feeReceivingContractAccount: feeReceivingContractAccountPDA,
          systemProgram: SystemProgram.programId,
        })
        .signers([contributor])
        .rpc();
      await measureComputeUnitsAndStorage(registerTxSignature);

      console.log(
        `Contributor ${i + 1} registered successfully with the address:`,
        contributor.publicKey.toBase58()
      );
      contributors.push(contributor);
    }

    // Fetch the ContributorDataAccount to verify all contributors are registered
    const contributorData = await program.account.contributorDataAccount.fetch(
      contributorDataAccountPDA
    );
    console.log(
      "Total number of registered contributors in ContributorDataAccount:",
      contributorData.contributors.length
    );

    // Verify each contributor is registered in ContributorDataAccount
    contributors.forEach((contributor, index) => {
      const isRegistered = contributorData.contributors.some((c) =>
        c.rewardAddress.equals(contributor.publicKey)
      );
      assert.isTrue(
        isRegistered,
        `Contributor ${
          index + 1
        } should be registered in ContributorDataAccount`
      );
    });
  });
});

describe("TXID Monitoring and Verification", () => {
  it("Adds and verifies multiple TXIDs for monitoring with parallel processing", async () => {
    const numTxids = NUMBER_OF_SIMULATED_REPORTS;
    const BATCH_SIZE = 4; // Process TXIDs in batches of 4

    // Helper function to generate a random TXID
    const generateRandomTxid = () => {
      return [...Array(64)]
        .map(() => Math.floor(Math.random() * 16).toString(16))
        .join("");
    };

    // Generate all TXIDs upfront
    const txids = Array(numTxids).fill(null).map(() => generateRandomTxid());
    const expectedAmountLamports = COST_IN_SOL_OF_ADDING_PASTEL_TXID_FOR_MONITORING * web3.LAMPORTS_PER_SOL;
    const expectedAmountStr = expectedAmountLamports.toString();

    // Process TXIDs in parallel batches
    for (let i = 0; i < txids.length; i += BATCH_SIZE) {
      const currentBatch = txids.slice(i, i + BATCH_SIZE);
      
      // Process batch in parallel
      await Promise.all(currentBatch.map(async (txid) => {
        // Create PDA for pending payment account
        const preimageString = "pending_payment" + txid + admin.publicKey.toBase58();
        const preimageBytes = Buffer.from(preimageString, "utf8");
        const seedHash = crypto.createHash("sha256").update(preimageBytes).digest();
        const [pendingPaymentAccountPDA] = web3.PublicKey.findProgramAddressSync(
          [seedHash],
          program.programId
        );

        // Add pending payment
        const addPendingPaymentTxSignature = await program.methods
          .addPendingPayment(txid, new BN(expectedAmountStr), { pending: {} })
          .accountsPartial({
            pendingPaymentAccount: pendingPaymentAccountPDA,
            oracleContractState: oracleContractState.publicKey,
            user: admin.publicKey,
            systemProgram: web3.SystemProgram.programId,
          })
          .rpc();
        await measureComputeUnitsAndStorage(addPendingPaymentTxSignature);

        // Add TXID for monitoring
        const addTxidTxSignature = await program.methods
          .addTxidForMonitoring({ txid: txid })
          .accountsPartial({
            oracleContractState: oracleContractState.publicKey,
            caller: admin.publicKey,
            pendingPaymentAccount: pendingPaymentAccountPDA,
            user: admin.publicKey,
            systemProgram: web3.SystemProgram.programId,
          })
          .rpc();
        await measureComputeUnitsAndStorage(addTxidTxSignature);

        // Immediately verify the pending payment account
        const pendingPaymentData = await program.account.pendingPaymentAccount.fetch(
          pendingPaymentAccountPDA
        );

        // Verify pending payment data
        assert.strictEqual(
          pendingPaymentData.pendingPayment.txid,
          txid,
          `The TXID in PendingPayment should match the monitored TXID: ${txid}`
        );
        
        assert.strictEqual(
          pendingPaymentData.pendingPayment.expectedAmount.toNumber(),
          expectedAmountLamports,
          `The expected amount in PendingPayment should match for TXID: ${txid}`
        );

        const paymentStatusJson = JSON.stringify(pendingPaymentData.pendingPayment.paymentStatus);
        assert.strictEqual(
          paymentStatusJson,
          JSON.stringify({ pending: {} }),
          `The payment status for TXID: ${txid} should be 'Pending'`
        );

        console.log(`TXID ${txid} added and verified successfully`);
      }));

      // Optional: Add a small delay between batches to prevent rate limiting
      if (i + BATCH_SIZE < txids.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    // Final verification of all TXIDs in oracle contract state
    const state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );

    // Verify all TXIDs are in the monitored list
    txids.forEach(txid => {
      assert(
        state.monitoredTxids.includes(txid),
        `TXID ${txid} should be in the monitored list`
      );
    });

    console.log(`Successfully added and verified ${numTxids} TXIDs`);
  });
});

describe("Data Report Submission", () => {
  it("Submits multiple data reports for different TXIDs with consensus and dissent", async () => {
    const seedPreamble = "pastel_tx_status_report";

    // Transfer SOL to contributors in parallel
    const transferAmountSOL = 1.0;
    await Promise.all(
      contributors.map(async (contributor) => {
        const transferTransaction = new anchor.web3.Transaction().add(
          anchor.web3.SystemProgram.transfer({
            fromPubkey: admin.publicKey,
            toPubkey: contributor.publicKey,
            lamports: transferAmountSOL * anchor.web3.LAMPORTS_PER_SOL,
          })
        );

        await provider.sendAndConfirm(transferTransaction);
        console.log(
          `Transferred ${transferAmountSOL} SOL to contributor account with address ${contributor.publicKey.toBase58()}`
        );
      })
    );

    // Find PDAs once outside the loops
    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    const [txidSubmissionCountsAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("txid_submission_counts")],
        program.programId
      );

    const [aggregatedConsensusDataAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("aggregated_consensus_data")],
        program.programId
      );

    const [tempReportAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("temp_tx_status_report")],
      program.programId
    );

    // Fetch monitored TXIDs from the updated state
    const state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );
    const monitoredTxids = state.monitoredTxids;

    // Process TXIDs in parallel batches
    const BATCH_SIZE = 4; // Adjust based on your needs
    for (let i = 0; i < monitoredTxids.length; i += BATCH_SIZE) {
      const currentBatch = monitoredTxids.slice(i, i + BATCH_SIZE);
      await Promise.all(
        currentBatch.map(async (txid) => {
          // Generate random file hash
          const randomFileHash = [...Array(6)]
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join("");

          console.log(
            `Processing batch for TXID ${txid} with hash ${randomFileHash}`
          );

          // Process contributors in parallel batches
          const CONTRIBUTOR_BATCH_SIZE = 4;
          for (
            let j = 0;
            j < contributors.length;
            j += CONTRIBUTOR_BATCH_SIZE
          ) {
            const contributorBatch = contributors.slice(
              j,
              j + CONTRIBUTOR_BATCH_SIZE
            );

            // Create all the submission promises for this batch
            const submissionPromises = contributorBatch.map(
              async (contributor, batchIndex) => {
                const contributorIndex = j + batchIndex;
                const rewardAddress = contributor.publicKey;

                // Calculate error probability
                const errorProbability =
                  contributorIndex < BAD_CONTRIBUTOR_INDEX
                    ? 0
                    : (contributorIndex - BAD_CONTRIBUTOR_INDEX + 1) /
                      (contributors.length - BAD_CONTRIBUTOR_INDEX);
                const isIncorrect = Math.random() < errorProbability;

                const txidStatusValue = isIncorrect
                  ? TxidStatusEnum.Invalid
                  : TxidStatusEnum.MinedActivated;
                const pastelTicketTypeValue = PastelTicketTypeEnum.Nft;

                const preimageString =
                  seedPreamble + txid + rewardAddress.toBase58();
                const preimageBytes = Buffer.from(preimageString, "utf8");
                const seedHash = crypto
                  .createHash("sha256")
                  .update(preimageBytes)
                  .digest();

                const [reportAccountPDA] =
                  web3.PublicKey.findProgramAddressSync(
                    [seedHash],
                    program.programId
                  );

                try {
                  const submitTxSignature = await program.methods
                    .submitDataReport(
                      txid,
                      isIncorrect ? { invalid: {} } : { minedActivated: {} },
                      { nft: {} }, // Using PastelTicketType.Nft directly
                      randomFileHash,
                      contributor.publicKey
                    )
                    .accountsPartial({
                      reportAccount: reportAccountPDA,
                      tempReportAccount: tempReportAccountPDA,
                      contributorDataAccount: contributorDataAccountPDA,
                      txidSubmissionCountsAccount:
                        txidSubmissionCountsAccountPDA,
                      aggregatedConsensusDataAccount:
                        aggregatedConsensusDataAccountPDA,
                      oracleContractState: oracleContractState.publicKey,
                      user: contributor.publicKey,
                      systemProgram: web3.SystemProgram.programId,
                    })
                    .preInstructions([
                      ComputeBudgetProgram.setComputeUnitLimit({
                        units: 1_400_000,
                      }),
                    ])
                    .signers([contributor])
                    .rpc();

                  await measureComputeUnitsAndStorage(submitTxSignature);
                  console.log(
                    `Data report for TXID ${txid} submitted by contributor ${contributor.publicKey.toBase58()}`
                  );
                } catch (error) {
                  handleSubmissionError(error, contributor, contributorIndex);
                }
              }
            );

            // Wait for all submissions in this batch to complete
            await Promise.all(submissionPromises);
          }

          // Verify consensus after all contributors have submitted
          await verifyConsensus(txid, aggregatedConsensusDataAccountPDA);
        })
      );
    }

    // Final validation of contributor states
    await validateContributorStates(contributorDataAccountPDA);
  });
});

// Utility function to handle submission errors
function handleSubmissionError(
  error: any,
  contributor: any,
  contributorIndex: number
) {
  const anchorError = anchor.AnchorError.parse(error.logs);
  if (anchorError) {
    if (
      anchorError.error.errorCode.code === "ContributorBanned" &&
      contributorIndex >= BAD_CONTRIBUTOR_INDEX
    ) {
      console.log(
        `Expected 'ContributorBanned' error for contributor ${contributor.publicKey.toBase58()}: ${
          anchorError.error.errorMessage
        }`
      );
    } else if (
      anchorError.error.errorCode.code === "EnoughReportsSubmittedForTxid" &&
      contributorIndex >= MIN_NUMBER_OF_ORACLES
    ) {
      console.log(
        `Expected 'EnoughReportsSubmittedForTxid' error for contributor ${contributor.publicKey.toBase58()}: ${
          anchorError.error.errorMessage
        }`
      );
    } else {
      console.error(
        `Unexpected error: ${
          anchorError.error.errorCode.code || "Unknown error"
        } - ${anchorError.error.errorMessage}`
      );
    }
  } else {
    console.error(`Error parsing error code: ${error.toString()}`);
  }
}

// Utility function to verify consensus for a TXID
async function verifyConsensus(
  txid: string,
  aggregatedConsensusDataAccountPDA: web3.PublicKey
) {
  const aggregatedConsensusDataAccount =
    await program.account.aggregatedConsensusDataAccount.fetch(
      aggregatedConsensusDataAccountPDA
    );

  const consensusData = aggregatedConsensusDataAccount.consensusData.find(
    (data) => data.txid === txid
  );

  if (consensusData) {
    const maxWeight = [...consensusData.statusWeights].sort((a, b) =>
      new Decimal(b.sub(a).toString()).div(new Decimal(1e9)).toDP(9).toNumber()
    )[0];

    const consensusStatusIndex = consensusData.statusWeights.findIndex(
      (weight) => weight.eq(maxWeight)
    );

    const consensusStatus = [
      "Invalid",
      "PendingMining",
      "MinedPendingActivation",
      "MinedActivated",
    ][consensusStatusIndex];

    console.log(`Consensus Status for TXID ${txid}:`, consensusStatus);
    assert(
      consensusStatus === "MinedActivated",
      `Majority consensus for TXID ${txid} should be 'MinedActivated'`
    );
  } else {
    console.log(`No consensus data found for TXID ${txid}`);
  }
}

// Utility function to validate final contributor states
async function validateContributorStates(
  contributorDataAccountPDA: web3.PublicKey
) {
  console.log(`Now checking the state of each contributor:`);
  const contributorData = await program.account.contributorDataAccount.fetch(
    contributorDataAccountPDA
  );

  await Promise.all(
    contributors.map(async (contributor) => {
      const currentContributorData = contributorData.contributors.find((c) =>
        c.rewardAddress.equals(contributor.publicKey)
      );

      if (!currentContributorData) {
        throw new Error(
          `Contributor data not found for address ${contributor.publicKey.toBase58()}`
        );
      }

      // Log contributor state
      console.log(`______________________________________________________`);
      console.log(`Contributor: ${contributor.publicKey.toBase58()}`);
      console.log(
        `Compliance Score: ${currentContributorData.complianceScore}`
      );
      console.log(
        `Total Reports Submitted: ${currentContributorData.totalReportsSubmitted}`
      );
      console.log(
        `Accurate Reports Count: ${currentContributorData.accurateReportsCount}`
      );
      console.log(`Current Streak: ${currentContributorData.currentStreak}`);
      console.log(
        `Reliability Score: ${currentContributorData.reliabilityScore}`
      );
      console.log(
        `Consensus Failures: ${currentContributorData.consensusFailures}`
      );
      console.log(`Ban Expiry: ${currentContributorData.banExpiry}`);
      console.log(
        `Is Eligible for Rewards: ${currentContributorData.isEligibleForRewards}`
      );
      console.log(
        `Is Recently Active: ${currentContributorData.isRecentlyActive}`
      );
      console.log(`Is Reliable: ${currentContributorData.isReliable}`);
    })
  );
}

describe("Data Cleanup Verification", () => {
  it("Verifies that data is cleaned up post-consensus", async () => {
    const txidsToCheck = trackedTxids;

    const [tempReportAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("temp_tx_status_report")],
      program.programId
    );

    const tempReportAccountData =
      await program.account.tempTxStatusReportAccount.fetch(
        tempReportAccountPDA
      );

    txidsToCheck.forEach((txid) => {
      const isTxidPresentInTempReport = tempReportAccountData.reports.some(
        (report) => {
          const commonDataIndex = report.commonDataRef.toNumber(); // Convert BN to number
          const commonData =
            tempReportAccountData.commonReports[commonDataIndex]; // Use converted index
          return commonData.txid === txid;
        }
      );
      assert.isFalse(
        isTxidPresentInTempReport,
        `TXID ${txid} should be cleaned up from TempTxStatusReportAccount`
      );
    });

    console.log(
      "Data cleanup post-consensus verification completed successfully."
    );
  });
});

describe("Payment Processing by Bridge Contract", () => {
  it("Processes payments for monitored TXIDs", async () => {
    const COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING = new BN(
      COST_IN_SOL_OF_ADDING_PASTEL_TXID_FOR_MONITORING * web3.LAMPORTS_PER_SOL
    );
    // Derive the FeeReceivingContractAccount PDA
    const [feeReceivingContractAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("fee_receiving_contract")],
        program.programId
      );

    // Fetch monitored TXIDs from the updated state
    const state = await program.account.oracleContractState.fetch(
      oracleContractState.publicKey
    );
    const monitoredTxids = state.monitoredTxids;

    for (const txid of monitoredTxids) {
      // Transfer the payment for the TXID from the admin account to the fee-receiving contract
      const transferTransaction = new anchor.web3.Transaction().add(
        anchor.web3.SystemProgram.transfer({
          fromPubkey: admin.publicKey,
          toPubkey: feeReceivingContractAccountPDA,
          lamports:
            COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING.toNumber(),
        })
      );

      const transferTxSignature = await provider.sendAndConfirm(
        transferTransaction
      );
      await measureComputeUnitsAndStorage(transferTxSignature);
      console.log(
        `Transferred payment for TXID ${txid} to fee-receiving contract`
      );

      // Manually create the seed for pendingPaymentAccountPDA
      const preimageString =
        "pending_payment" + txid + admin.publicKey.toBase58();
      const preimageBytes = Buffer.from(preimageString, "utf8");
      const seedHash = crypto
        .createHash("sha256")
        .update(preimageBytes)
        .digest();
      const [pendingPaymentAccountPDA] = web3.PublicKey.findProgramAddressSync(
        [seedHash],
        program.programId
      );

      // Process the payment in the oracle contract
      await program.methods
        .processPayment(
          txid,
          COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING
        )
        .accountsPartial({
          sourceAccount: admin.publicKey,
          oracleContractState: oracleContractState.publicKey,
          pendingPaymentAccount: pendingPaymentAccountPDA,
          systemProgram: web3.SystemProgram.programId,
        })
        .rpc();

      // Fetch the updated PendingPayment struct to verify the payment status
      const pendingPaymentData =
        await program.account.pendingPaymentAccount.fetch(
          pendingPaymentAccountPDA
        );

      // Convert paymentStatus to JSON and compare the stringified version
      const paymentStatusJson = JSON.stringify(
        pendingPaymentData.pendingPayment.paymentStatus
      );
      assert.strictEqual(
        paymentStatusJson,
        JSON.stringify({ received: {} }),
        `The payment status for TXID: ${txid} should be 'Received'`
      );

      console.log(`Payment processed for TXID ${txid}`);
    }
  });
});

describe("Eligibility for Rewards", () => {
  it("should check if contributors meet reward eligibility criteria", async () => {
    // Fetch the ContributorDataAccount
    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    const contributorData = await program.account.contributorDataAccount.fetch(
      contributorDataAccountPDA
    );

    // Loop through each contributor and check their eligibility
    for (const contributor of contributors) {
      const currentContributorData = contributorData.contributors.find((c) =>
        c.rewardAddress.equals(contributor.publicKey)
      );

      // Check if the contributor data exists
      if (!currentContributorData) {
        throw new Error(
          `Contributor data not found for address ${contributor.publicKey.toBase58()}`
        );
      }

      // Log all fields for each contributor
      console.log(`Contributor: ${contributor.publicKey.toBase58()}`);
      console.log(
        `Registration Entrance Fee Transaction Signature: ${currentContributorData.registrationEntranceFeeTransactionSignature}`
      );
      console.log(
        `Compliance Score: ${currentContributorData.complianceScore}`
      );
      console.log(
        `Last Active Timestamp: ${currentContributorData.lastActiveTimestamp}`
      );
      console.log(
        `Total Reports Submitted: ${currentContributorData.totalReportsSubmitted}`
      );
      console.log(
        `Accurate Reports Count: ${currentContributorData.accurateReportsCount}`
      );
      console.log(`Current Streak: ${currentContributorData.currentStreak}`);
      console.log(
        `Reliability Score: ${currentContributorData.reliabilityScore}`
      );
      console.log(
        `Consensus Failures: ${currentContributorData.consensusFailures}`
      );
      console.log(`Ban Expiry: ${currentContributorData.banExpiry}`);
      console.log(
        `Is Eligible for Rewards: ${currentContributorData.isEligibleForRewards}`
      );
      console.log(
        `Is Recently Active: ${currentContributorData.isRecentlyActive}`
      );
      console.log(`Is Reliable: ${currentContributorData.isReliable}`);
      console.log(`______________________________________________________`);

      // Define your eligibility criteria based on your contract logic
      const isEligibleForRewards =
        currentContributorData.totalReportsSubmitted >=
          MIN_REPORTS_FOR_REWARD &&
        currentContributorData.reliabilityScore.gte(
          MIN_RELIABILITY_SCORE_FOR_REWARD
        ) &&
        currentContributorData.complianceScore.gte(
          MIN_COMPLIANCE_SCORE_FOR_REWARD
        );
      assert(
        currentContributorData.isEligibleForRewards === isEligibleForRewards,
        `Eligibility for rewards for contributor with address ${contributor.publicKey.toBase58()} should be correctly determined`
      );
    }
  });
});

describe("Reward Distribution for Eligible Contributor", () => {
  it("should distribute rewards correctly from the reward pool", async () => {
    // Choose an eligible contributor
    const eligibleContributor = contributors[0]; // Assuming the first contributor is eligible

    // Find the PDA for the RewardPoolAccount
    const [rewardPoolAccountPDA] = await web3.PublicKey.findProgramAddress(
      [Buffer.from("reward_pool")],
      program.programId
    );

    const [contributorDataAccountPDA] = await web3.PublicKey.findProgramAddress(
      [Buffer.from("contributor_data")],
      program.programId
    );

    // Get initial balances
    const initialRewardPoolBalance = await provider.connection.getBalance(
      rewardPoolAccountPDA
    );
    console.log(`Initial reward pool balance: ${initialRewardPoolBalance}`);

    const initialContributorBalance = await provider.connection.getBalance(
      eligibleContributor.publicKey
    );
    console.log(`Initial contributor balance: ${initialContributorBalance}`);

    const initialOracleContractStateBalance =
      await provider.connection.getBalance(oracleContractState.publicKey);
    console.log(
      `Initial oracle contract state balance: ${initialOracleContractStateBalance}`
    );

    try {
      // Request reward for the eligible contributor
      const requestRewardTxSignature = await program.methods
        .requestReward(eligibleContributor.publicKey)
        .accountsPartial({
          rewardPoolAccount: rewardPoolAccountPDA,
          oracleContractState: oracleContractState.publicKey,
          contributorDataAccount: contributorDataAccountPDA,
          contributor: eligibleContributor.publicKey,
          systemProgram: web3.SystemProgram.programId,
        })
        .rpc();
      await measureComputeUnitsAndStorage(requestRewardTxSignature);

      console.log("Reward request successful");
    } catch (error) {
      console.error("Error requesting reward:", error);
      throw error;
    }

    // Wait for the transaction to be confirmed
    await new Promise((resolve) => setTimeout(resolve, 250));

    // Get updated balances
    const updatedRewardPoolBalance = await provider.connection.getBalance(
      rewardPoolAccountPDA
    );
    console.log(`Updated reward pool balance: ${updatedRewardPoolBalance}`);

    const updatedContributorBalance = await provider.connection.getBalance(
      eligibleContributor.publicKey
    );
    console.log(`Updated contributor balance: ${updatedContributorBalance}`);

    const updatedOracleContractStateBalance =
      await provider.connection.getBalance(oracleContractState.publicKey);
    console.log(
      `Updated oracle contract state balance: ${updatedOracleContractStateBalance}`
    );

    // Check if the reward pool balance decreased by the correct amount
    const rewardPoolDifference =
      initialRewardPoolBalance - updatedRewardPoolBalance;
    expect(rewardPoolDifference).to.equal(
      BASE_REWARD_AMOUNT_IN_LAMPORTS,
      "Reward pool should decrease by the reward amount"
    );

    // Check if the contributor balance increased by the correct amount
    const contributorDifference =
      updatedContributorBalance - initialContributorBalance;
    expect(contributorDifference).to.equal(
      BASE_REWARD_AMOUNT_IN_LAMPORTS,
      "Contributor balance should increase by the reward amount"
    );

    // The oracle contract state balance should not change
    expect(updatedOracleContractStateBalance).to.equal(
      initialOracleContractStateBalance,
      "Oracle contract state balance should not change"
    );
  });
});

describe("Request Reward for Ineligible Contributor", () => {
  it("should not allow reward requests from ineligible contributors", async () => {
    // Choose an ineligible contributor
    const ineligibleContributor = contributors[contributors.length - 1]; // Assuming the last contributor is ineligible

    // Find the PDA for the RewardPoolAccount
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );

    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    try {
      // Attempt to request reward
      const requestRewardTxSignature = await program.methods
        .requestReward(ineligibleContributor.publicKey)
        .accountsPartial({
          rewardPoolAccount: rewardPoolAccountPDA,
          oracleContractState: oracleContractState.publicKey,
          contributorDataAccount: contributorDataAccountPDA,
        })
        .rpc();
      await measureComputeUnitsAndStorage(requestRewardTxSignature);

      throw new Error(
        "Reward request should have failed for ineligible contributor"
      );
    } catch (error) {
      const anchorError = anchor.AnchorError.parse(error.logs);
      if (anchorError) {
        assert.equal(
          anchorError.error.errorCode.code,
          "NotEligibleForReward",
          "Should throw NotEligibleForReward error"
        );
      } else {
        console.error(`Error parsing error code: ${error.toString()}`);
        // Decide on handling unparsed errors
      }
    }
  });
});

describe("Reallocation of Oracle State", () => {
  it("Simulates account reallocation when capacity is reached", async () => {
    // Find PDAs
    const [contributorDataAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("contributor_data")],
      program.programId
    );

    const [feeReceivingContractAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("fee_receiving_contract")],
        program.programId
      );

    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );

    // Get initial sizes of accounts
    const initialContributorDataSize = (
      await provider.connection.getAccountInfo(contributorDataAccountPDA)
    ).data.length;
    console.log("Initial ContributorData size:", initialContributorDataSize);

    // We'll add contributors until we need reallocation
    const contributorsToAdd = 60;
    const newContributors = [];

    // Pre-generate all contributor keypairs
    for (let i = 0; i < contributorsToAdd; i++) {
      newContributors.push(web3.Keypair.generate());
    }

    // Track when reallocation happens
    let reallocated = false;

    for (let i = 0; i < contributorsToAdd; i++) {
      const newContributor = newContributors[i];

      // Fund the fee receiving account for registration
      const fundTx = new web3.Transaction().add(
        web3.SystemProgram.transfer({
          fromPubkey: admin.publicKey,
          toPubkey: feeReceivingContractAccountPDA,
          lamports: REGISTRATION_ENTRANCE_FEE_SOL * web3.LAMPORTS_PER_SOL,
        })
      );

      await provider.sendAndConfirm(fundTx);

      try {
        // Try to register new contributor
        const tx = await program.methods
          .registerNewDataContributor()
          .accountsStrict({
            contributorDataAccount: contributorDataAccountPDA,
            contributorAccount: newContributor.publicKey,
            rewardPoolAccount: rewardPoolAccountPDA,
            feeReceivingContractAccount: feeReceivingContractAccountPDA,
            systemProgram: SystemProgram.programId,
          })
          .signers([newContributor])
          .rpc();

        console.log(`Successfully registered contributor ${i + 1}`);
      } catch (error) {
        // If we get a specific error about account size, trigger reallocation
        console.log("Registration error:", error.toString());

        if (
          error.toString().includes("AccountDidNotFit") ||
          error.toString().includes("0x1") ||
          error.toString().includes("insufficient account size")
        ) {
          console.log("Account capacity reached, performing reallocation...");

          // Find all required PDAs for reallocation
          const [tempReportAccountPDA] = web3.PublicKey.findProgramAddressSync(
            [Buffer.from("temp_tx_status_report")],
            program.programId
          );

          const [txidSubmissionCountsAccountPDA] =
            web3.PublicKey.findProgramAddressSync(
              [Buffer.from("txid_submission_counts")],
              program.programId
            );

          const [aggregatedConsensusDataAccountPDA] =
            web3.PublicKey.findProgramAddressSync(
              [Buffer.from("aggregated_consensus_data")],
              program.programId
            );

          // Trigger reallocation with all required accounts
          const reallocateTx = await program.methods
            .reallocateOracleState()
            .accountsStrict({
              oracleContractState: oracleContractState.publicKey,
              adminPubkey: admin.publicKey,
              tempReportAccount: tempReportAccountPDA,
              contributorDataAccount: contributorDataAccountPDA,
              txidSubmissionCountsAccount: txidSubmissionCountsAccountPDA,
              aggregatedConsensusDataAccount: aggregatedConsensusDataAccountPDA,
              systemProgram: web3.SystemProgram.programId,
            })
            .rpc();

          console.log("Reallocation transaction completed");
          reallocated = true;

          // Wait a bit for the reallocation to take effect
          await new Promise((resolve) => setTimeout(resolve, 1000));

          // Retry registration after reallocation
          await program.methods
            .registerNewDataContributor()
            .accountsStrict({
              contributorDataAccount: contributorDataAccountPDA,
              contributorAccount: newContributor.publicKey,
              rewardPoolAccount: rewardPoolAccountPDA,
              feeReceivingContractAccount: feeReceivingContractAccountPDA,
              systemProgram: SystemProgram.programId,
            })
            .signers([newContributor])
            .rpc();

          console.log("Successfully registered after reallocation");
        } else {
          throw error;
        }
      }

      // Add delay between registrations to avoid rate limiting
      await new Promise((resolve) => setTimeout(resolve, 200));
    }

    // Verify final account size and successful registrations
    const finalContributorDataSize = (
      await provider.connection.getAccountInfo(contributorDataAccountPDA)
    ).data.length;
    console.log("Final ContributorData size:", finalContributorDataSize);

    // Verify the data
    const contributorData = await program.account.contributorDataAccount.fetch(
      contributorDataAccountPDA
    );

    // Only assert size increase if reallocation happened
    if (reallocated) {
      assert(
        finalContributorDataSize > initialContributorDataSize,
        "Account size should have increased after reallocation"
      );
    }

    assert(
      contributorData.contributors.length >= contributorsToAdd,
      "All contributors should be registered after reallocation"
    );
  });
});

describe("Withdrawal of Funds", () => {
  it("Allows admin to withdraw funds from reward pool and fee-receiving contract", async () => {
    // Find PDAs for accounts
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );

    const [feeReceivingContractAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("fee_receiving_contract")],
        program.programId
      );

    // Fund the rewardPoolAccount PDA with 1 SOL for testing
    const fundingAmount = web3.LAMPORTS_PER_SOL; // 1 SOL
    const fundRewardPoolTx = new web3.Transaction().add(
      web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: rewardPoolAccountPDA,
        lamports: fundingAmount,
      })
    );

    const fundRewardPoolTxSignature = await provider.sendAndConfirm(
      fundRewardPoolTx
    );
    await measureComputeUnitsAndStorage(fundRewardPoolTxSignature);
    console.log(
      `Funded reward_pool_account PDA with ${fundingAmount} lamports`
    );

    // Fund the fee receiving contract for testing
    const fundFeeReceivingTx = new web3.Transaction().add(
      web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: feeReceivingContractAccountPDA,
        lamports: fundingAmount,
      })
    );

    const fundFeeReceivingTxSignature = await provider.sendAndConfirm(
      fundFeeReceivingTx
    );
    await measureComputeUnitsAndStorage(fundFeeReceivingTxSignature);
    console.log(
      `Funded fee_receiving_contract PDA with ${fundingAmount} lamports`
    );

    // Wait for funding transactions to be confirmed
    await new Promise((resolve) => setTimeout(resolve, 500));

    // Get initial balances
    const initialRewardPoolBalance = await provider.connection.getBalance(
      rewardPoolAccountPDA
    );
    const initialFeeReceivingBalance = await provider.connection.getBalance(
      feeReceivingContractAccountPDA
    );
    const initialAdminBalance = await provider.connection.getBalance(
      admin.publicKey
    );

    console.log(`Initial reward pool balance: ${initialRewardPoolBalance}`);
    console.log(`Initial fee receiving balance: ${initialFeeReceivingBalance}`);
    console.log(`Initial admin balance: ${initialAdminBalance}`);

    // Define withdrawal amounts as half of initial balances
    const rewardPoolWithdrawalAmount = Math.floor(initialRewardPoolBalance / 2);
    const feeReceivingWithdrawalAmount = Math.floor(
      initialFeeReceivingBalance / 2
    );

    try {
      // Withdraw funds
      const withdrawFundsTxSignature = await program.methods
        .withdrawFunds(
          new BN(rewardPoolWithdrawalAmount),
          new BN(feeReceivingWithdrawalAmount)
        )
        .accountsStrict({
          oracleContractState: oracleContractState.publicKey,
          adminAccount: admin.publicKey,
          rewardPoolAccount: rewardPoolAccountPDA,
          feeReceivingContractAccount: feeReceivingContractAccountPDA,
          systemProgram: SystemProgram.programId,
        })
        .rpc();
      await measureComputeUnitsAndStorage(withdrawFundsTxSignature);

      console.log("Withdrawal transaction completed successfully");
    } catch (error) {
      console.error("Error during withdrawal:", error);
      throw error;
    }

    // Wait for the withdrawal transaction to be confirmed
    await new Promise((resolve) => setTimeout(resolve, 500));

    // Get updated balances
    const updatedRewardPoolBalance = await provider.connection.getBalance(
      rewardPoolAccountPDA
    );
    const updatedFeeReceivingBalance = await provider.connection.getBalance(
      feeReceivingContractAccountPDA
    );
    const updatedAdminBalance = await provider.connection.getBalance(
      admin.publicKey
    );

    console.log(`Updated reward pool balance: ${updatedRewardPoolBalance}`);
    console.log(`Updated fee receiving balance: ${updatedFeeReceivingBalance}`);
    console.log(`Updated admin balance: ${updatedAdminBalance}`);

    // Calculate the expected total withdrawal amount
    const expectedTotalWithdrawal =
      rewardPoolWithdrawalAmount + feeReceivingWithdrawalAmount;

    // Calculate the actual withdrawal amount, accounting for transaction fees
    const actualWithdrawal = updatedAdminBalance - initialAdminBalance;

    // Allow for a small margin due to transaction fees
    const margin = 10_000;

    // Assertions with detailed error messages
    assert(
      Math.abs(actualWithdrawal - expectedTotalWithdrawal) <= margin,
      `Admin balance should increase by approximately ${expectedTotalWithdrawal} lamports (allowing for transaction fees), but increased by ${actualWithdrawal} lamports`
    );

    assert.equal(
      updatedRewardPoolBalance,
      initialRewardPoolBalance - rewardPoolWithdrawalAmount,
      `Reward pool balance should decrease by exactly ${rewardPoolWithdrawalAmount} lamports`
    );

    assert.equal(
      updatedFeeReceivingBalance,
      initialFeeReceivingBalance - feeReceivingWithdrawalAmount,
      `Fee receiving contract balance should decrease by exactly ${feeReceivingWithdrawalAmount} lamports`
    );

    console.log(`
      Withdrawal test summary:
      - Reward pool withdrawal: ${rewardPoolWithdrawalAmount} lamports
      - Fee receiving withdrawal: ${feeReceivingWithdrawalAmount} lamports
      - Total withdrawal: ${expectedTotalWithdrawal} lamports
      - Actual admin balance increase: ${actualWithdrawal} lamports
      Test completed successfully!
    `);
  });

  it("Should not allow non-admin to withdraw funds", async () => {
    // Create a non-admin keypair
    const nonAdmin = web3.Keypair.generate();

    // Fund the non-admin account with some SOL for transaction fees
    const fundTx = new web3.Transaction().add(
      web3.SystemProgram.transfer({
        fromPubkey: admin.publicKey,
        toPubkey: nonAdmin.publicKey,
        lamports: web3.LAMPORTS_PER_SOL * 0.1, // 0.1 SOL
      })
    );

    const fundTxSignature = await provider.sendAndConfirm(fundTx);
    await measureComputeUnitsAndStorage(fundTxSignature);

    // Find PDAs
    const [rewardPoolAccountPDA] = web3.PublicKey.findProgramAddressSync(
      [Buffer.from("reward_pool")],
      program.programId
    );

    const [feeReceivingContractAccountPDA] =
      web3.PublicKey.findProgramAddressSync(
        [Buffer.from("fee_receiving_contract")],
        program.programId
      );

    try {
      // Attempt to withdraw funds as non-admin
      await program.methods
        .withdrawFunds(new BN(1000000), new BN(1000000))
        .accountsStrict({
          oracleContractState: oracleContractState.publicKey,
          adminAccount: nonAdmin.publicKey,
          rewardPoolAccount: rewardPoolAccountPDA,
          feeReceivingContractAccount: feeReceivingContractAccountPDA,
          systemProgram: SystemProgram.programId,
        })
        .signers([nonAdmin])
        .rpc();

      assert.fail("Transaction should have failed for non-admin");
    } catch (error) {
      const anchorError = anchor.AnchorError.parse(error.logs);
      if (anchorError) {
        assert.equal(
          anchorError.error.errorCode.code,
          "UnauthorizedWithdrawalAccount",
          "Should throw UnauthorizedWithdrawalAccount error"
        );
        console.log("Non-admin withdrawal correctly rejected");
      } else {
        throw error;
      }
    }
  });
});

// After all tests
after(async function () {
  console.log(`Total compute units used: ${totalComputeUnitsUsed}`);
  console.log(`Max account storage used: ${maxAccountStorageUsed} bytes`);
});


---
./depends/funcs.mk.tmp
---


---
./depends/packages/libgmp.mk
---
# libgmp.mk - Build rules for GMP

package=libgmp
$(package)_version=6.2.1
$(package)_download_path=https://gmplib.org/download/gmp
$(package)_file_name=gmp-$(libgmp_version).tar.lz
$(package)_sha256_hash=2c7f4f0d370801b2849c48c9ef3f59553b5f1d3791d070cffb04599f9fc67b41
$(package)_dependencies=

define $(package)_build_cmds
    echo "BUILD_DIR is: $(BUILD_DIR)"
	cd \$(BUILD_DIR) && patch -p1 < \$(abs_top_srcdir)/depends/patches/libgmp/disable-asm-for-arm64.patch
	cd \$(BUILD_DIR) && ./configure --prefix=\$(PREFIX) \$(HOST) --enable-shared --enable-static
	cd \$(BUILD_DIR) && make -j\$(JOBS)
	cd \$(BUILD_DIR) && make install
endef


---
./depends/patches/libgmp/disable-asm-for-arm64.patch
---
--- configure.ac.orig
+++ configure.ac
@@ -150,6 +150,10 @@
   GMP_LDFLAGS="$GMP_LDFLAGS -Xlinker -m -Xlinker elf_x86_64"
   ;;
 esac
+
+case $host in
+  aarch64*) GMP_CFLAGS="$GMP_CFLAGS -DNO_ASM" ;;
+esac

 AC_ARG_ENABLE(assembly,
 [AS_HELP_STRING([--disable-assembly], [use generic C code instead of assembly])])


---
./migrations/deploy.ts
---
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


---
./programs/solana_pastel_oracle_program/Cargo.toml
---
[package]
name = "solana_pastel_oracle_program"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "solana_pastel_oracle_program"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { version = "0.30.1", features = ["init-if-needed"] }
uint = "0.9.5"
fixed = "1.27.0"
num-traits = "0.2.18"
typenum = "1.17.0"


---
./programs/solana_pastel_oracle_program/Xargo.toml
---
[target.bpfel-unknown-unknown.dependencies.std]
features = []


---
./programs/solana_pastel_oracle_program/src/lib.rs
---
pub mod big_number;
pub mod fixed_exp;
pub mod fixed_giga;

use crate::fixed_giga::*;
use anchor_lang::prelude::*;
use anchor_lang::solana_program::hash::{hash, Hash};
use anchor_lang::solana_program::sysvar::clock::Clock;
use anchor_lang::solana_program::sysvar::rent::Rent;
use anchor_lang::system_program::{transfer, Transfer};
use anchor_lang::solana_program::{program::invoke, system_instruction};

const REGISTRATION_ENTRANCE_FEE_IN_LAMPORTS: u64 = 10_000_000; // 0.10 SOL in lamports
const MIN_NUMBER_OF_ORACLES: usize = 8; // Minimum number of oracles to calculate consensus
const MIN_REPORTS_FOR_REWARD: u32 = 10; // Data Contributor must submit at least 10 reports to be eligible for rewards
const BASE_REWARD_AMOUNT_IN_LAMPORTS: u64 = 100_000; // 0.0001 SOL in lamports is the base reward amount, which is scaled based on the number of highly reliable contributors
const COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING: u64 = 100_000; // 0.0001 SOL in lamports
const PERMANENT_BAN_THRESHOLD: u32 = 100; // Number of non-consensus report submissions for permanent ban
const CONTRIBUTIONS_FOR_PERMANENT_BAN: u32 = 250; // Considered for permanent ban after 250 contributions
const TEMPORARY_BAN_THRESHOLD: u32 = 5; // Number of non-consensus report submissions for temporary ban
const CONTRIBUTIONS_FOR_TEMPORARY_BAN: u32 = 50; // Considered for temporary ban after 50 contributions
const TEMPORARY_BAN_DURATION: u32 = 24 * 60 * 60; // Duration of temporary ban in seconds (e.g., 1 day)
const MAX_DURATION_IN_SECONDS_FROM_LAST_REPORT_SUBMISSION_BEFORE_COMPUTING_CONSENSUS: u32 = 10 * 60; // Maximum duration in seconds from last report submission for a given TXID before computing consensus (e.g., 10 minutes)
const DATA_RETENTION_PERIOD: u32 = 24 * 60 * 60; // How long to keep data in the contract state (1 day)
const SUBMISSION_COUNT_RETENTION_PERIOD: u32 = 24 * 60 * 60; // Number of seconds to retain submission counts (i.e., 24 hours)
const TXID_STATUS_VARIANT_COUNT: usize = 4; // Manually define the number of variants in TxidStatus
const MAX_TXID_LENGTH: usize = 64; // Maximum length of a TXID

const MIN_COMPLIANCE_SCORE_FOR_REWARD: u64 = 65_000000000; // Data Contributor must have a compliance score of at least 80 to be eligible for rewards
const MIN_RELIABILITY_SCORE_FOR_REWARD: u64 = 80_000000000; // Minimum reliability score to be eligible for rewards
const BASE_SCORE_INCREMENT: u64 = 20_000000000; // 20.0
const RELIABILITY_RATIO_THRESHOLD: u64 = 800000000; // 0.8
const DECAY_RATE: u64 = 990000000; // 0.99
const MAX_STREAK_BONUS: u64 = 3_000000000; // 3.0
const MAX_COMPLIANCE_SCORE: u64 = 100_000000000; // 100.0
const MID_COMPLIANCE_SCORE: u64 = 50_000000000; // 50.0

const ONE_TENTH: u64 = 100000000; // 0.1
const FIVE_TENTH: u64 = 500000000; // 0.5

#[error_code]
pub enum OracleError {
    ContributorAlreadyRegistered,
    UnregisteredOracle,
    InvalidTxid,
    InvalidFileHashLength,
    MissingPastelTicketType,
    MissingFileHash,
    RegistrationFeeNotPaid,
    NotEligibleForReward,
    NotBridgeContractAddress,
    InsufficientFunds,
    UnauthorizedWithdrawalAccount,
    InvalidPaymentAmount,
    PaymentNotFound,
    PendingPaymentAlreadyInitialized,
    AccountAlreadyInitialized,
    PendingPaymentInvalidAmount,
    InvalidPaymentStatus,
    InvalidTxidStatus,
    InvalidPastelTicketType,
    ContributorNotRegistered,
    ContributorBanned,
    EnoughReportsSubmittedForTxid,
    MaxSizeExceeded,
    InvalidAccountName,
}

pub fn create_seed(seed_preamble: &str, txid: &str, reward_address: &Pubkey) -> Hash {
    // Concatenate the string representations. Reward address is Base58-encoded by default.
    let preimage_string = format!("{}{}{}", seed_preamble, txid, reward_address);
    // msg!("create_seed: generated preimage string: {}", preimage_string);
    // Convert the concatenated string to bytes
    let preimage_bytes = preimage_string.as_bytes();
    // Compute hash
    let seed_hash = hash(preimage_bytes);
    // msg!("create_seed: generated seed hash: {:?}", seed_hash);
    seed_hash
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy, AnchorSerialize, AnchorDeserialize)]
pub enum TxidStatus {
    Invalid,
    PendingMining,
    MinedPendingActivation,
    MinedActivated,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy, AnchorSerialize, AnchorDeserialize)]
pub enum PastelTicketType {
    Sense,
    Cascade,
    Nft,
    InferenceApi,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, AnchorSerialize, AnchorDeserialize)]
pub struct PastelTxStatusReport {
    pub txid: String,
    pub txid_status: TxidStatus,
    pub pastel_ticket_type: Option<PastelTicketType>,
    pub first_6_characters_of_sha3_256_hash_of_corresponding_file: Option<String>,
    pub timestamp: u32,
    pub contributor_reward_address: Pubkey,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, AnchorSerialize, AnchorDeserialize)]
pub struct CommonReportData {
    pub txid: String,
    pub txid_status: TxidStatus,
    pub pastel_ticket_type: Option<PastelTicketType>,
    pub first_6_characters_of_sha3_256_hash_of_corresponding_file: Option<String>,
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct SpecificReportData {
    pub contributor_reward_address: Pubkey,
    pub timestamp: u32,
    pub common_data_ref: u64, // Reference to CommonReportData
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct TempTxStatusReport {
    pub common_data_ref: u64, // Index to CommonReportData in common_reports
    pub specific_data: SpecificReportData,
}

#[account]
pub struct TempTxStatusReportAccount {
    pub reports: Vec<TempTxStatusReport>,
    pub common_reports: Vec<CommonReportData>,
    pub specific_reports: Vec<SpecificReportData>,
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct TxidSubmissionCount {
    pub txid: String,
    pub count: u32,
    pub last_updated: u32,
}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
pub struct PendingPayment {
    pub txid: String,
    pub expected_amount: u64,
    pub payment_status: PaymentStatus,
}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
pub enum PaymentStatus {
    Pending,
    Received,
}

#[account]
pub struct PastelTxStatusReportAccount {
    pub report: PastelTxStatusReport,
}

#[derive(Accounts)]
#[instruction(txid: String, reward_address: Pubkey)]
pub struct SubmitDataReport<'info> {
    #[account(
        init_if_needed,
        payer = user,
        seeds = [create_seed("pastel_tx_status_report", &txid, &user.key()).as_ref()],
        bump,
        space = 8 + (64 + 1 + 2 + 7 + 8 + 32 + 128) // Discriminator +  txid String (max length of 64) + txid_status + pastel_ticket_type + first_6_characters_of_sha3_256_hash_of_corresponding_file + timestamp + contributor_reward_address + cushion
    )]
    pub report_account: Account<'info, PastelTxStatusReportAccount>,

    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    #[account(mut)]
    pub user: Signer<'info>,

    #[account(mut, seeds = [b"temp_tx_status_report"], bump)]
    pub temp_report_account: Account<'info, TempTxStatusReportAccount>,

    #[account(mut, seeds = [b"contributor_data"], bump)]
    pub contributor_data_account: Account<'info, ContributorDataAccount>,

    #[account(mut, seeds = [b"txid_submission_counts"], bump)]
    pub txid_submission_counts_account: Account<'info, TxidSubmissionCountsAccount>,

    #[account(mut, seeds = [b"aggregated_consensus_data"], bump)]
    pub aggregated_consensus_data_account: Account<'info, AggregatedConsensusDataAccount>,

    pub system_program: Program<'info, System>,
}

fn update_submission_count(
    txid_submission_counts_account: &mut Account<TxidSubmissionCountsAccount>,
    txid: &str,
) -> Result<()> {
    // Get the current timestamp
    let current_timestamp = Clock::get()?.unix_timestamp as u32;

    let counts = &mut txid_submission_counts_account.submission_counts;

    // Use binary search directly without sorting, assuming counts is always kept sorted
    match counts.binary_search_by(|c| c.txid.as_str().cmp(txid)) {
        Ok(index) => {
            // Found the txid, update the count
            let count = &mut counts[index];
            count.count += 1;
            count.last_updated = current_timestamp;
        }
        Err(index) => {
            // Not found, insert at the position to keep the vector sorted
            counts.insert(
                index,
                TxidSubmissionCount {
                    txid: txid.to_string(),
                    count: 1,
                    last_updated: current_timestamp,
                },
            );
        }
    }

    Ok(())
}

pub fn get_report_account_pda(
    program_id: &Pubkey,
    txid: &str,
    contributor_reward_address: &Pubkey,
) -> (Pubkey, u8) {
    let seed_hash = create_seed("pastel_tx_status_report", txid, contributor_reward_address);
    Pubkey::find_program_address(&[seed_hash.as_ref()], program_id)
}

fn get_aggregated_data<'a>(
    aggregated_data_account: &'a Account<AggregatedConsensusDataAccount>,
    txid: &str,
) -> Option<&'a AggregatedConsensusData> {
    let consensus_data = &aggregated_data_account.consensus_data;
    match consensus_data.binary_search_by(|d| d.txid.as_str().cmp(txid)) {
        Ok(index) => Some(&consensus_data[index]),
        Err(_) => None,
    }
}

fn compute_consensus(aggregated_data: &AggregatedConsensusData) -> (TxidStatus, String) {
    // Find the index of the maximum status weight
    let (max_status_index, _) = aggregated_data
        .status_weights
        .iter()
        .enumerate()
        .max_by_key(|&(_, &weight)| weight)
        .unwrap();

    let consensus_status = usize_to_txid_status(max_status_index).unwrap_or(TxidStatus::Invalid);

    // Find the hash with the maximum weight
    let consensus_hash = aggregated_data
        .hash_weights
        .iter()
        .max_by_key(|hash_weight| hash_weight.weight)
        .map(|hash_weight| hash_weight.hash.clone())
        .unwrap_or_default();

    (consensus_status, consensus_hash)
}

fn apply_bans(contributor: &mut Contributor, current_timestamp: u32, is_accurate: bool) {
    if is_accurate {
        return; // No need to apply bans if the report is accurate
    }

    let failures = contributor.consensus_failures;
    let total_submissions = contributor.total_reports_submitted;

    if total_submissions >= CONTRIBUTIONS_FOR_PERMANENT_BAN
        && failures >= PERMANENT_BAN_THRESHOLD
    {
        contributor.ban_expiry = u32::MAX;
        msg!(
            "Contributor: {} is permanently banned as of {}",
            contributor.reward_address,
            current_timestamp
        );
    } else if total_submissions >= CONTRIBUTIONS_FOR_TEMPORARY_BAN
        && failures % TEMPORARY_BAN_THRESHOLD == 0
    {
        contributor.ban_expiry = current_timestamp + TEMPORARY_BAN_DURATION;
        msg!(
            "Contributor: {} is temporarily banned until {}",
            contributor.reward_address,
            contributor.ban_expiry
        );
    }
}

fn update_scores(contributor: &mut Contributor, current_timestamp: u32, is_accurate: bool) {
    let time_diff = current_timestamp
        .saturating_sub(contributor.last_active_timestamp)
        .to_fixed_giga();
    let hours_inactive = time_diff.div_up(3600_000000000);
    let current_streak = contributor.current_streak as u64 * ONE_TENTH;

    // Dynamic scaling for accuracy
    let accuracy_scaling = if is_accurate {
        (ONE + current_streak).min(TWO) // Increasing bonus for consecutive accuracy
    } else {
        ONE
    };

    let time_weight = ONE.div_up(ONE + hours_inactive.div_up(480_000000000));

    // Adjusted base increment for a more gradual increase
    let score_increment = BASE_SCORE_INCREMENT
        .mul_down(accuracy_scaling)
        .mul_down(time_weight);

    // Exponential penalty for inaccuracies
    let score_decrement = BASE_SCORE_INCREMENT
        .mul_up(ONE + contributor.consensus_failures as u64 * FIVE_TENTH)
        .min(MAX_STREAK_BONUS);

    // Adjusted decay rate 0.99
    let decay_factor = DECAY_RATE.pow_up(hours_inactive.div_up(24_000000000));

    let streak_bonus = if is_accurate {
        current_streak.min(MAX_STREAK_BONUS) // Enhanced streak bonus
    } else {
        ZERO
    };

    if is_accurate {
        contributor.total_reports_submitted += 1;
        contributor.accurate_reports_count += 1;
        contributor.current_streak += 1;
        contributor.compliance_score += score_increment + streak_bonus;
    } else {
        contributor.total_reports_submitted += 1;
        contributor.current_streak = 0;
        contributor.consensus_failures += 1;
        contributor.compliance_score = contributor.compliance_score.saturating_sub(score_decrement);
    }

    contributor.compliance_score = contributor.compliance_score.mul_up(decay_factor);

    // Integrating reliability score into compliance score calculation
    let reliability_factor = contributor
        .accurate_reports_count
        .to_fixed_giga()
        .div_down(contributor.total_reports_submitted.to_fixed_giga())
        .clamp(ZERO, ONE);
    contributor.compliance_score = contributor
        .compliance_score
        .mul_down(reliability_factor)
        .min(MAX_COMPLIANCE_SCORE);

    contributor.compliance_score = logistic_scale(
        contributor.compliance_score,
        MAX_COMPLIANCE_SCORE,
        ONE_TENTH,
        MID_COMPLIANCE_SCORE,
    ); // Adjusted logistic scaling

    contributor.reliability_score = reliability_factor * 100;

    log_score_updates(contributor);
}

fn logistic_scale(score: u64, max_value: u64, steepness: u64, midpoint: u64) -> u64 {
    // max_value / (1 + e ^ (-steepness * (score - midpoint)))
    let denom = if score > midpoint {
        ONE + steepness.mul_down(score - midpoint).neg_exp_down()
    } else if score < midpoint {
        ONE + steepness.mul_down(midpoint - score).exp_down()
    } else {
        TWO
    };
    max_value.div_down(denom)
}

fn log_score_updates(contributor: &Contributor) {
    msg!(
        "Scores After Update: Address: {}, Compliance Score: {}, Reliability Score: {}",
        contributor.reward_address,
        contributor.compliance_score,
        contributor.reliability_score
    );
}

fn update_statuses(contributor: &mut Contributor, current_timestamp: u32) {
    let recent_activity_threshold = 86_400; // 24 hours in seconds
    contributor.is_recently_active =
        current_timestamp.saturating_sub(contributor.last_active_timestamp) < recent_activity_threshold;

    let reliability_ratio = if contributor.total_reports_submitted > 0 {
        (contributor.accurate_reports_count as u64 * ONE)
            / (contributor.total_reports_submitted as u64)
    } else {
        0
    };

    contributor.is_reliable = reliability_ratio >= RELIABILITY_RATIO_THRESHOLD;
    contributor.is_eligible_for_rewards = contributor.calculate_is_eligible_for_rewards();
}

fn update_contributor(contributor: &mut Contributor, current_timestamp: u32, is_accurate: bool) {
    // Skip update if the contributor is banned
    if contributor.calculate_is_banned(current_timestamp) {
        msg!(
            "Contributor is currently banned and cannot be updated: {}",
            contributor.reward_address
        );
        return;
    }

    // Update scores
    update_scores(contributor, current_timestamp, is_accurate);

    // Apply bans based on report accuracy
    apply_bans(contributor, current_timestamp, is_accurate);

    // Update contributor statuses
    update_statuses(contributor, current_timestamp);
}

fn calculate_consensus(
    aggregated_data_account: &Account<AggregatedConsensusDataAccount>,
    temp_report_account: &TempTxStatusReportAccount,
    contributor_data_account: &mut Account<ContributorDataAccount>,
    txid: &str,
) -> Result<()> {
    let current_timestamp = Clock::get()?.unix_timestamp as u32;
    let (consensus_status, consensus_hash) = get_aggregated_data(aggregated_data_account, txid)
        .map(|data| compute_consensus(data))
        .unwrap_or((TxidStatus::Invalid, String::new()));

    let mut updated_contributors = Vec::new();
    let mut contributor_count = 0;

    for temp_report in &temp_report_account.reports {
        let common_data = &temp_report_account.common_reports[temp_report.common_data_ref as usize];
        let specific_data = &temp_report.specific_data;

        if common_data.txid == txid
            && !updated_contributors.contains(&specific_data.contributor_reward_address)
        {
            let contributors = &mut contributor_data_account.contributors;

            // Use binary search directly without sorting
            match contributors.binary_search_by(|c| c.reward_address.cmp(&specific_data.contributor_reward_address)) {
                Ok(index) => {
                    let contributor = &mut contributors[index];
                    let is_accurate = common_data.txid_status == consensus_status
                        && common_data
                            .first_6_characters_of_sha3_256_hash_of_corresponding_file
                            .as_ref()
                            .map_or(false, |hash| hash == &consensus_hash);
                    update_contributor(contributor, current_timestamp, is_accurate);
                }
                Err(_) => {
                    // Contributor not found; this should not happen
                    msg!(
                        "Contributor not found: {}",
                        specific_data.contributor_reward_address
                    );
                    return Err(OracleError::ContributorNotRegistered.into());
                }
            }

            updated_contributors.push(specific_data.contributor_reward_address);
            contributor_count += 1;
        }
    }
    msg!("Consensus reached for TXID: {}, Status: {:?}, Hash: {}, Number of Contributors Included: {}", txid, consensus_status, consensus_hash, contributor_count);

    Ok(())
}

pub fn apply_permanent_bans(contributor_data_account: &mut Account<ContributorDataAccount>) {
    let initial_len = contributor_data_account.contributors.len();
    contributor_data_account
        .contributors
        .retain(|c| c.ban_expiry != u32::MAX);

    let removed_count = initial_len - contributor_data_account.contributors.len();
    if removed_count > 0 {
        msg!(
            "Removed {} permanently banned contributors. Total contributors now: {}",
            removed_count,
            contributor_data_account.contributors.len()
        );
    }
}

fn post_consensus_tasks(
    txid_submission_counts_account: &mut Account<TxidSubmissionCountsAccount>,
    aggregated_data_account: &mut Account<AggregatedConsensusDataAccount>,
    temp_report_account: &mut TempTxStatusReportAccount,
    contributor_data_account: &mut Account<ContributorDataAccount>,
    txid: &str,
) -> Result<()> {
    let current_timestamp = Clock::get()?.unix_timestamp as u32;

    apply_permanent_bans(contributor_data_account);

    msg!("Now cleaning up unneeded data in TempTxStatusReportAccount...");
    // Cleanup unneeded data in TempTxStatusReportAccount
    temp_report_account.reports.retain(|temp_report| {
        // Access the common data from the TempTxStatusReportAccount
        let common_data = &temp_report_account.common_reports[temp_report.common_data_ref as usize];
        let specific_data = &temp_report.specific_data;
        common_data.txid != txid
            && current_timestamp - specific_data.timestamp < DATA_RETENTION_PERIOD
    });

    msg!("Now cleaning up unneeded data in AggregatedConsensusDataAccount...");
    // Cleanup unneeded data in AggregatedConsensusDataAccount
    aggregated_data_account
        .consensus_data
        .retain(|data| current_timestamp - data.last_updated < DATA_RETENTION_PERIOD);

    msg!("Now cleaning up unneeded data in TxidSubmissionCountsAccount...");
    // Cleanup old submission counts in TxidSubmissionCountsAccount
    txid_submission_counts_account
        .submission_counts
        .retain(|count| current_timestamp - count.last_updated < SUBMISSION_COUNT_RETENTION_PERIOD);

    msg!("Done with post-consensus tasks!");
    Ok(())
}

fn aggregate_consensus_data(
    aggregated_data_account: &mut Account<AggregatedConsensusDataAccount>,
    report: &PastelTxStatusReport,
    weight: u64,
    txid: &str,
) -> Result<()> {
    let scaled_weight = weight * 100; // Scaling by a factor of 100
    let current_timestamp = Clock::get()?.unix_timestamp as u32;

    let consensus_data = &mut aggregated_data_account.consensus_data;

    // Use binary search directly without sorting
    match consensus_data.binary_search_by(|d| d.txid.as_str().cmp(txid)) {
        Ok(index) => {
            // Update existing data
            let data_entry = &mut consensus_data[index];
            data_entry.status_weights[report.txid_status as usize] += scaled_weight;
            if let Some(hash) = &report.first_6_characters_of_sha3_256_hash_of_corresponding_file {
                update_hash_weight(&mut data_entry.hash_weights, hash, scaled_weight);
            }
            data_entry.last_updated = current_timestamp;
            data_entry.first_6_characters_of_sha3_256_hash_of_corresponding_file = report
                .first_6_characters_of_sha3_256_hash_of_corresponding_file
                .clone()
                .unwrap_or_default();
        }
        Err(index) => {
            // Insert new data at the correct position to keep the vector sorted
            let mut new_data = AggregatedConsensusData {
                txid: txid.to_string(),
                status_weights: [0; TXID_STATUS_VARIANT_COUNT],
                hash_weights: Vec::new(),
                first_6_characters_of_sha3_256_hash_of_corresponding_file: report
                    .first_6_characters_of_sha3_256_hash_of_corresponding_file
                    .clone()
                    .unwrap_or_default(),
                last_updated: current_timestamp,
            };
            new_data.status_weights[report.txid_status as usize] += scaled_weight;
            if let Some(hash) = &report.first_6_characters_of_sha3_256_hash_of_corresponding_file {
                new_data.hash_weights.push(HashWeight {
                    hash: hash.clone(),
                    weight: scaled_weight,
                });
            }
            consensus_data.insert(index, new_data);
        }
    }

    Ok(())
}

fn find_or_add_common_report_data(
    temp_report_account: &mut TempTxStatusReportAccount,
    common_data: &CommonReportData,
) -> u64 {
    // Use binary search directly without sorting
    match temp_report_account
        .common_reports
        .binary_search_by(|data| data.txid.cmp(&common_data.txid))
    {
        Ok(index) => index as u64,
        Err(index) => {
            temp_report_account
                .common_reports
                .insert(index, common_data.clone());
            index as u64
        }
    }
}

pub fn submit_data_report_helper(
    ctx: Context<SubmitDataReport>,
    txid: String,
    report: PastelTxStatusReport,
    contributor_reward_address: Pubkey,
) -> Result<()> {

    // Directly access accounts from the context
    let txid_submission_counts_account: &mut Account<'_, TxidSubmissionCountsAccount> =
        &mut ctx.accounts.txid_submission_counts_account;
    let aggregated_data_account = &mut ctx.accounts.aggregated_consensus_data_account;
    let temp_report_account = &mut ctx.accounts.temp_report_account;
    let contributor_data_account = &mut ctx.accounts.contributor_data_account;

    // Retrieve the submission count for the given txid from the PDA account
    let txid_submission_count: usize = txid_submission_counts_account
        .submission_counts
        .iter()
        .find(|c| c.txid == txid)
        .map_or(0, |c| c.count as usize);

    // Check if the number of submissions is already at or exceeds MIN_NUMBER_OF_ORACLES
    if txid_submission_count >= MIN_NUMBER_OF_ORACLES {
        msg!("Enough reports have already been submitted for this txid");
        return Err(OracleError::EnoughReportsSubmittedForTxid.into());
    }

    // Validate the data report before any contributor-specific checks
    // msg!("Validating data report: {:?}", report);
    validate_data_contributor_report(&report)?;

    // Check if the contributor is registered and not banned
    // msg!("Checking if contributor is registered and not banned");
    let contributor = contributor_data_account
        .contributors
        .iter()
        .find(|c| c.reward_address == contributor_reward_address)
        .ok_or(OracleError::ContributorNotRegistered)?;

    if contributor.calculate_is_banned(Clock::get()?.unix_timestamp as u32) {
        return Err(OracleError::ContributorBanned.into());
    }

    // Clone the String before using it
    let first_6_characters_of_sha3_256_hash_of_corresponding_file = report
        .first_6_characters_of_sha3_256_hash_of_corresponding_file
        .clone();

    // Extracting common data from the report
    // msg!("Extracting common data from the report");
    let common_data = CommonReportData {
        txid: report.txid.clone(),
        txid_status: report.txid_status,
        pastel_ticket_type: report.pastel_ticket_type,
        first_6_characters_of_sha3_256_hash_of_corresponding_file:
            first_6_characters_of_sha3_256_hash_of_corresponding_file,
    };

    // Finding or adding common report data
    // msg!("Finding or adding common report data");
    let common_data_index = find_or_add_common_report_data(temp_report_account, &common_data);

    // Creating specific report data
    // msg!("Creating specific report data");
    let specific_report = SpecificReportData {
        contributor_reward_address,
        timestamp: report.timestamp,
        common_data_ref: common_data_index,
    };

    // Creating a temporary report entry
    // msg!("Creating a temporary report entry");
    let temp_report: TempTxStatusReport = TempTxStatusReport {
        common_data_ref: common_data_index,
        specific_data: specific_report,
    };

    // Add the temporary report to the TempTxStatusReportAccount
    // msg!("Adding the temporary report to the TempTxStatusReportAccount");
    temp_report_account.reports.push(temp_report);

    // Update submission count and consensus-related data
    // msg!("Updating submission count and consensus-related data");
    update_submission_count(txid_submission_counts_account, &txid)?;

    let compliance_score = contributor.compliance_score;
    let reliability_score = contributor.reliability_score;
    let weight = compliance_score + reliability_score;
    aggregate_consensus_data(aggregated_data_account, &report, weight, &txid)?;

    // Check for consensus and perform related tasks
    if should_calculate_consensus(txid_submission_counts_account, &txid)? {
        msg!(
            "We now have enough reports to calculate consensus for txid: {}",
            txid
        );

        let contributor_data_account: &mut Account<'_, ContributorDataAccount> =
            &mut ctx.accounts.contributor_data_account;
        msg!("Calculating consensus...");
        calculate_consensus(
            aggregated_data_account,
            temp_report_account,
            contributor_data_account,
            &txid,
        )?;

        msg!("Performing post-consensus tasks...");
        post_consensus_tasks(
            txid_submission_counts_account,
            aggregated_data_account,
            temp_report_account,
            contributor_data_account,
            &txid,
        )?;
    }

    // Log the new size of temp_tx_status_reports
    msg!("New size of temp_tx_status_reports in bytes after processing report for txid {} from contributor {}: {}", txid, contributor_reward_address, temp_report_account.reports.len() * std::mem::size_of::<TempTxStatusReport>());

    Ok(())
}

#[derive(Accounts)]
#[instruction(txid: String)]
pub struct HandleConsensus<'info> {
    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,
}

#[account]
pub struct PendingPaymentAccount {
    pub pending_payment: PendingPayment,
}

#[derive(Accounts)]
#[instruction(txid: String)]
pub struct HandlePendingPayment<'info> {
    #[account(
        init_if_needed,
        payer = user,
        seeds = [create_seed("pending_payment", &txid, &user.key()).as_ref()],
        bump,
        space = 8 + std::mem::size_of::<PendingPayment>() + 64 // Adjusted for discriminator
    )]
    pub pending_payment_account: Account<'info, PendingPaymentAccount>,

    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,
}

pub fn add_pending_payment_helper(
    ctx: Context<HandlePendingPayment>,
    txid: String,
    pending_payment: PendingPayment,
) -> Result<()> {
    let pending_payment_account = &mut ctx.accounts.pending_payment_account;

    // Ensure the account is being initialized for the first time to avoid re-initialization
    if !pending_payment_account.pending_payment.txid.is_empty()
        && pending_payment_account.pending_payment.txid != txid
    {
        return Err(OracleError::PendingPaymentAlreadyInitialized.into());
    }

    // Ensure txid is correct and other fields are properly set
    if pending_payment.txid != txid {
        return Err(OracleError::InvalidTxid.into());
    }

    // Store the pending payment in the account
    pending_payment_account.pending_payment = pending_payment;

    msg!(
        "Pending payment account initialized: TXID: {}, Expected Amount: {}, Status: {:?}",
        pending_payment_account.pending_payment.txid,
        pending_payment_account.pending_payment.expected_amount,
        pending_payment_account.pending_payment.payment_status
    );

    Ok(())
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Contributor {
    pub reward_address: Pubkey,
    pub registration_entrance_fee_transaction_signature: String,
    pub compliance_score: u64,
    pub last_active_timestamp: u32,
    pub total_reports_submitted: u32,
    pub accurate_reports_count: u32,
    pub current_streak: u32,
    pub reliability_score: u64,
    pub consensus_failures: u32,
    pub ban_expiry: u32,
    pub is_eligible_for_rewards: bool,
    pub is_recently_active: bool,
    pub is_reliable: bool,
}

#[account]
pub struct ContributorDataAccount {
    pub contributors: Vec<Contributor>,
}

#[account]
pub struct TxidSubmissionCountsAccount {
    pub submission_counts: Vec<TxidSubmissionCount>,
}

#[account]
pub struct AggregatedConsensusDataAccount {
    pub consensus_data: Vec<AggregatedConsensusData>,
}

#[account]
pub struct OracleContractState {
    pub is_initialized: bool,
    pub admin_pubkey: Pubkey,
    pub txid_submission_counts: Vec<TxidSubmissionCount>,
    pub monitored_txids: Vec<String>,
    pub reward_pool_account: Pubkey,
    pub fee_receiving_contract_account: Pubkey,
    pub txid_submission_counts_account: Pubkey,
    pub aggregated_consensus_data_account: Pubkey,
    pub bridge_contract_pubkey: Pubkey,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 10_240)] // Adjusted space
    pub oracle_contract_state: Account<'info, OracleContractState>,
    #[account(mut)]
    pub user: Signer<'info>,

    // Account for TempTxStatusReportAccount PDA
    #[account(
        init,
        seeds = [b"temp_tx_status_report"],
        bump,
        payer = user,
        space = 10_240
    )]
    pub temp_report_account: Account<'info, TempTxStatusReportAccount>,

    // Account for ContributorDataAccount PDA
    #[account(
        init,
        seeds = [b"contributor_data"],
        bump,
        payer = user,
        space = 10_240
    )]
    pub contributor_data_account: Account<'info, ContributorDataAccount>,

    // Account for TxidSubmissionCountsAccount PDA
    #[account(
        init,
        seeds = [b"txid_submission_counts"],
        bump,
        payer = user,
        space = 10_240
    )]
    pub txid_submission_counts_account: Account<'info, TxidSubmissionCountsAccount>,

    // Account for AggregatedConsensusDataAccount PDA
    #[account(
        init,
        seeds = [b"aggregated_consensus_data"],
        bump,
        payer = user,
        space = 10_240
    )]
    pub aggregated_consensus_data_account: Account<'info, AggregatedConsensusDataAccount>,

    // System program is needed for account creation
    pub system_program: Program<'info, System>,
}

impl<'info> Initialize<'info> {
    pub fn initialize_oracle_state(&mut self) -> Result<()> {
        msg!("Setting up Oracle Contract State");

        let state = &mut self.oracle_contract_state;
        // Ensure the oracle_contract_state is not already initialized
        if state.is_initialized {
            return Err(OracleError::AccountAlreadyInitialized.into());
        }

        state.is_initialized = true;
        state.admin_pubkey = self.user.key();
        msg!("Admin Pubkey set to: {:?}", self.user.key());

        state.monitored_txids = Vec::new();
        msg!("Monitored Txids Vector initialized");

        state.bridge_contract_pubkey = Pubkey::default();
        msg!("Bridge Contract Pubkey set to default");

        msg!("Oracle Contract State Initialization Complete");
        Ok(())
    }
}

fn reallocate_temp_report_account<'info>(
    temp_report_account: &mut Account<'info, TempTxStatusReportAccount>,
    payer: &AccountInfo<'info>,
    system_program: &AccountInfo<'info>,
) -> Result<()> {
    const REALLOCATION_THRESHOLD: f32 = 0.9;
    const ADDITIONAL_SPACE: usize = 10_240;
    const MAX_SIZE: usize = 100 * 1024; // 100KB

    let current_size = temp_report_account.to_account_info().data_len();
    let current_usage = temp_report_account.reports.len() * std::mem::size_of::<TempTxStatusReport>();
    let usage_ratio = current_usage as f32 / current_size as f32;

    if usage_ratio > REALLOCATION_THRESHOLD {
        let new_size = std::cmp::min(current_size + ADDITIONAL_SPACE, MAX_SIZE);

        // Prevent reallocating beyond MAX_SIZE
        if new_size > MAX_SIZE {
            msg!(
                "Cannot reallocate TempTxStatusReportAccount beyond MAX_SIZE of {} bytes.",
                MAX_SIZE
            );
            return Err(OracleError::MaxSizeExceeded.into());
        }

        // Attempt to reallocate
        temp_report_account.to_account_info().realloc(new_size, false)?;
        msg!(
            "TempTxStatusReportAccount reallocated from {} bytes to {} bytes.",
            current_size,
            new_size
        );

        // Calculate new rent minimum
        let rent = Rent::get()?;
        let new_rent_minimum = rent.minimum_balance(new_size);
        let current_lamports = temp_report_account.to_account_info().lamports();
        let lamports_needed = new_rent_minimum.saturating_sub(current_lamports);

        if lamports_needed > 0 {
            // Transfer lamports from payer to the account to meet rent exemption
            invoke(
                &system_instruction::transfer(
                    payer.key,
                    temp_report_account.to_account_info().key,
                    lamports_needed,
                ),
                &[
                    payer.clone(),
                    temp_report_account.to_account_info().clone(),
                    system_program.clone(),
                ],
            )?;
            msg!(
                "Transferred {} lamports from payer to TempTxStatusReportAccount to meet rent-exemption.",
                lamports_needed
            );
        }

        // Verify rent-exemption
        let updated_lamports = temp_report_account.to_account_info().lamports();
        let is_rent_exempt = rent.is_exempt(updated_lamports, new_size);
        if !is_rent_exempt {
            msg!(
                "TempTxStatusReportAccount is not rent-exempt after reallocation. Required: {}, Current: {}",
                new_rent_minimum,
                updated_lamports
            );
            return Err(OracleError::InsufficientFunds.into());
        }

        msg!(
            "TempTxStatusReportAccount is now rent-exempt with a size of {} bytes.",
            new_size
        );
    } else {
        msg!(
            "TempTxStatusReportAccount usage ratio ({:.2}) is below the reallocation threshold ({})",
            usage_ratio,
            REALLOCATION_THRESHOLD
        );
    }

    Ok(())
}

fn reallocate_contributor_data_account<'info>(
    contributor_data_account: &mut Account<'info, ContributorDataAccount>,
    payer: &AccountInfo<'info>,
    system_program: &AccountInfo<'info>,
) -> Result<()> {
    const REALLOCATION_THRESHOLD: f32 = 0.9;
    const ADDITIONAL_SPACE: usize = 10_240;
    const MAX_SIZE: usize = 100 * 1024; // 100KB

    let current_size = contributor_data_account.to_account_info().data_len();
    let current_usage = contributor_data_account.contributors.len() * std::mem::size_of::<Contributor>();
    let usage_ratio = current_usage as f32 / current_size as f32;

    if usage_ratio > REALLOCATION_THRESHOLD {
        let new_size = std::cmp::min(current_size + ADDITIONAL_SPACE, MAX_SIZE);

        // Prevent reallocating beyond MAX_SIZE
        if new_size > MAX_SIZE {
            msg!(
                "Cannot reallocate ContributorDataAccount beyond MAX_SIZE of {} bytes.",
                MAX_SIZE
            );
            return Err(OracleError::MaxSizeExceeded.into());
        }

        // Attempt to reallocate
        contributor_data_account.to_account_info().realloc(new_size, false)?;
        msg!(
            "ContributorDataAccount reallocated from {} bytes to {} bytes.",
            current_size,
            new_size
        );

        // Calculate new rent minimum
        let rent = Rent::get()?;
        let new_rent_minimum = rent.minimum_balance(new_size);
        let current_lamports = contributor_data_account.to_account_info().lamports();
        let lamports_needed = new_rent_minimum.saturating_sub(current_lamports);

        if lamports_needed > 0 {
            // Transfer lamports from payer to the account to meet rent exemption
            invoke(
                &system_instruction::transfer(
                    payer.key,
                    contributor_data_account.to_account_info().key,
                    lamports_needed,
                ),
                &[
                    payer.clone(),
                    contributor_data_account.to_account_info().clone(),
                    system_program.clone(),
                ],
            )?;
            msg!(
                "Transferred {} lamports from payer to ContributorDataAccount to meet rent-exemption.",
                lamports_needed
            );
        }

        // Verify rent-exemption
        let updated_lamports = contributor_data_account.to_account_info().lamports();
        let is_rent_exempt = rent.is_exempt(updated_lamports, new_size);
        if !is_rent_exempt {
            msg!(
                "ContributorDataAccount is not rent-exempt after reallocation. Required: {}, Current: {}",
                new_rent_minimum,
                updated_lamports
            );
            return Err(OracleError::InsufficientFunds.into());
        }

        msg!(
            "ContributorDataAccount is now rent-exempt with a size of {} bytes.",
            new_size
        );
    } else {
        msg!(
            "ContributorDataAccount usage ratio ({:.2}) is below the reallocation threshold ({})",
            usage_ratio,
            REALLOCATION_THRESHOLD
        );
    }

    Ok(())
}

fn reallocate_submission_counts_account<'info>(
    submission_counts_account: &mut Account<'info, TxidSubmissionCountsAccount>,
    payer: &AccountInfo<'info>,
    system_program: &AccountInfo<'info>,
) -> Result<()> {
    const REALLOCATION_THRESHOLD: f32 = 0.9;
    const ADDITIONAL_SPACE: usize = 10_240;
    const MAX_SIZE: usize = 100 * 1024; // 100KB

    let current_size = submission_counts_account.to_account_info().data_len();
    let current_usage = submission_counts_account
        .submission_counts
        .len()
        * std::mem::size_of::<TxidSubmissionCount>();
    let usage_ratio = current_usage as f32 / current_size as f32;

    if usage_ratio > REALLOCATION_THRESHOLD {
        let new_size = std::cmp::min(current_size + ADDITIONAL_SPACE, MAX_SIZE);

        // Prevent reallocating beyond MAX_SIZE
        if new_size > MAX_SIZE {
            msg!(
                "Cannot reallocate TxidSubmissionCountsAccount beyond MAX_SIZE of {} bytes.",
                MAX_SIZE
            );
            return Err(OracleError::MaxSizeExceeded.into());
        }

        // Attempt to reallocate
        submission_counts_account.to_account_info().realloc(new_size, false)?;
        msg!(
            "TxidSubmissionCountsAccount reallocated from {} bytes to {} bytes.",
            current_size,
            new_size
        );

        // Calculate new rent minimum
        let rent = Rent::get()?;
        let new_rent_minimum = rent.minimum_balance(new_size);
        let current_lamports = submission_counts_account.to_account_info().lamports();
        let lamports_needed = new_rent_minimum.saturating_sub(current_lamports);

        if lamports_needed > 0 {
            // Transfer lamports from payer to the account to meet rent exemption
            invoke(
                &system_instruction::transfer(
                    payer.key,
                    submission_counts_account.to_account_info().key,
                    lamports_needed,
                ),
                &[
                    payer.clone(),
                    submission_counts_account.to_account_info().clone(),
                    system_program.clone(),
                ],
            )?;
            msg!(
                "Transferred {} lamports from payer to TxidSubmissionCountsAccount to meet rent-exemption.",
                lamports_needed
            );
        }

        // Verify rent-exemption
        let updated_lamports = submission_counts_account.to_account_info().lamports();
        let is_rent_exempt = rent.is_exempt(updated_lamports, new_size);
        if !is_rent_exempt {
            msg!(
                "TxidSubmissionCountsAccount is not rent-exempt after reallocation. Required: {}, Current: {}",
                new_rent_minimum,
                updated_lamports
            );
            return Err(OracleError::InsufficientFunds.into());
        }

        msg!(
            "TxidSubmissionCountsAccount is now rent-exempt with a size of {} bytes.",
            new_size
        );
    } else {
        msg!(
            "TxidSubmissionCountsAccount usage ratio ({:.2}) is below the reallocation threshold ({})",
            usage_ratio,
            REALLOCATION_THRESHOLD
        );
    }

    Ok(())
}

fn reallocate_aggregated_consensus_data_account<'info>(
    aggregated_consensus_data_account: &mut Account<'info, AggregatedConsensusDataAccount>,
    payer: &AccountInfo<'info>,
    system_program: &AccountInfo<'info>,
) -> Result<()> {
    const REALLOCATION_THRESHOLD: f32 = 0.9;
    const ADDITIONAL_SPACE: usize = 10_240;
    const MAX_SIZE: usize = 100 * 1024; // 100KB

    let current_size = aggregated_consensus_data_account.to_account_info().data_len();
    let current_usage = aggregated_consensus_data_account
        .consensus_data
        .len()
        * std::mem::size_of::<AggregatedConsensusData>();
    let usage_ratio = current_usage as f32 / current_size as f32;

    if usage_ratio > REALLOCATION_THRESHOLD {
        let new_size = std::cmp::min(current_size + ADDITIONAL_SPACE, MAX_SIZE);

        // Prevent reallocating beyond MAX_SIZE
        if new_size > MAX_SIZE {
            msg!(
                "Cannot reallocate AggregatedConsensusDataAccount beyond MAX_SIZE of {} bytes.",
                MAX_SIZE
            );
            return Err(OracleError::MaxSizeExceeded.into());
        }

        // Attempt to reallocate
        aggregated_consensus_data_account.to_account_info().realloc(new_size, false)?;
        msg!(
            "AggregatedConsensusDataAccount reallocated from {} bytes to {} bytes.",
            current_size,
            new_size
        );

        // Calculate new rent minimum
        let rent = Rent::get()?;
        let new_rent_minimum = rent.minimum_balance(new_size);
        let current_lamports = aggregated_consensus_data_account.to_account_info().lamports();
        let lamports_needed = new_rent_minimum.saturating_sub(current_lamports);

        if lamports_needed > 0 {
            // Transfer lamports from payer to the account to meet rent exemption
            invoke(
                &system_instruction::transfer(
                    payer.key,
                    aggregated_consensus_data_account.to_account_info().key,
                    lamports_needed,
                ),
                &[
                    payer.clone(),
                    aggregated_consensus_data_account.to_account_info().clone(),
                    system_program.clone(),
                ],
            )?;
            msg!(
                "Transferred {} lamports from payer to AggregatedConsensusDataAccount to meet rent-exemption.",
                lamports_needed
            );
        }

        // Verify rent-exemption
        let updated_lamports = aggregated_consensus_data_account.to_account_info().lamports();
        let is_rent_exempt = rent.is_exempt(updated_lamports, new_size);
        if !is_rent_exempt {
            msg!(
                "AggregatedConsensusDataAccount is not rent-exempt after reallocation. Required: {}, Current: {}",
                new_rent_minimum,
                updated_lamports
            );
            return Err(OracleError::InsufficientFunds.into());
        }

        msg!(
            "AggregatedConsensusDataAccount is now rent-exempt with a size of {} bytes.",
            new_size
        );
    } else {
        msg!(
            "AggregatedConsensusDataAccount usage ratio ({:.2}) is below the reallocation threshold ({})",
            usage_ratio,
            REALLOCATION_THRESHOLD
        );
    }

    Ok(())
}

#[derive(Accounts)]
pub struct ReallocateOracleState<'info> {
    #[account(mut, has_one = admin_pubkey)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    pub admin_pubkey: Signer<'info>, // Admin is the payer

    pub system_program: Program<'info, System>,

    #[account(mut)]
    pub temp_report_account: Account<'info, TempTxStatusReportAccount>,

    #[account(mut)]
    pub contributor_data_account: Account<'info, ContributorDataAccount>,

    #[account(mut)]
    pub txid_submission_counts_account: Account<'info, TxidSubmissionCountsAccount>,

    #[account(mut)]
    pub aggregated_consensus_data_account: Account<'info, AggregatedConsensusDataAccount>,
}

impl<'info> ReallocateOracleState<'info> {
    pub fn execute(ctx: Context<ReallocateOracleState>) -> Result<()> {
        let payer = ctx.accounts.admin_pubkey.to_account_info(); // Admin is the payer
        let system_program = ctx.accounts.system_program.to_account_info();

        // Reallocate TempTxStatusReportAccount
        reallocate_temp_report_account(
            &mut ctx.accounts.temp_report_account,
            &payer,
            &system_program,
        )?;

        // Reallocate ContributorDataAccount
        reallocate_contributor_data_account(
            &mut ctx.accounts.contributor_data_account,
            &payer,
            &system_program,
        )?;

        // Reallocate TxidSubmissionCountsAccount
        reallocate_submission_counts_account(
            &mut ctx.accounts.txid_submission_counts_account,
            &payer,
            &system_program,
        )?;

        // Reallocate AggregatedConsensusDataAccount
        reallocate_aggregated_consensus_data_account(
            &mut ctx.accounts.aggregated_consensus_data_account,
            &payer,
            &system_program,
        )?;

        msg!("All accounts reallocated and rent-exempt status ensured.");
        Ok(())
    }
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct HashWeight {
    pub hash: String,
    pub weight: u64,
}

fn update_hash_weight(hash_weights: &mut Vec<HashWeight>, hash: &str, weight: u64) {
    if let Some(hash_weight) = hash_weights.iter_mut().find(|hw| hw.hash == hash) {
        hash_weight.weight += weight;
    } else {
        hash_weights.push(HashWeight {
            hash: hash.to_string(),
            weight,
        });
    }
}

// Struct to hold aggregated data for consensus calculation
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct AggregatedConsensusData {
    pub txid: String,
    pub status_weights: [u64; TXID_STATUS_VARIANT_COUNT],
    pub hash_weights: Vec<HashWeight>,
    pub first_6_characters_of_sha3_256_hash_of_corresponding_file: String,
    pub last_updated: u32, // Unix timestamp indicating the last update time
}

#[derive(Accounts)]
pub struct RequestReward<'info> {
    /// CHECK: OK
    #[account(mut, seeds = [b"reward_pool"], bump)]
    pub reward_pool_account: UncheckedAccount<'info>,
    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,
    #[account(mut)]
    pub contributor_data_account: Account<'info, ContributorDataAccount>,
    /// CHECK: This is the account we're transferring lamports to
    #[account(mut)]
    pub contributor: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
}

pub fn request_reward_helper(
    ctx: Context<RequestReward>,
    contributor_address: Pubkey,
) -> Result<()> {
    let contributor_data_account = &ctx.accounts.contributor_data_account;
    let reward_pool_account = &ctx.accounts.reward_pool_account;
    let contributor_account = &ctx.accounts.contributor;

    // Find the contributor in the PDA and check eligibility
    let contributor = contributor_data_account
        .contributors
        .iter()
        .find(|c| c.reward_address == contributor_address)
        .ok_or(OracleError::UnregisteredOracle)?;

    let current_unix_timestamp = Clock::get()?.unix_timestamp as u32;

    if !contributor.is_eligible_for_rewards {
        msg!(
            "Contributor is not eligible for rewards: {}",
            contributor_address
        );
        return Err(OracleError::NotEligibleForReward.into());
    }

    if contributor.calculate_is_banned(current_unix_timestamp) {
        msg!("Contributor is banned: {}", contributor_address);
        return Err(OracleError::ContributorBanned.into());
    }

    let reward_amount = BASE_REWARD_AMOUNT_IN_LAMPORTS;

    // Ensure the reward pool has sufficient funds
    if reward_pool_account.to_account_info().lamports() < reward_amount {
        msg!("Insufficient funds in reward pool");
        return Err(OracleError::InsufficientFunds.into());
    }

    // Transfer the reward from the reward pool to the contributor
    transfer(
        CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            Transfer {
                from: ctx.accounts.reward_pool_account.to_account_info(),
                to: contributor_account.to_account_info(),
            },
        )
        .with_signer(&[&[b"reward_pool", &[ctx.bumps.reward_pool_account]]]),
        reward_amount,
    )?;

    msg!(
        "Paid out Valid Reward Request: Contributor: {}, Amount: {}",
        contributor_address,
        reward_amount
    );

    Ok(())
}

#[derive(Accounts)]
pub struct RegisterNewDataContributor<'info> {
    /// CHECK: Manual checks are performed in the instruction to ensure the contributor_account is valid and safe to use.
    #[account(mut)]
    pub contributor_account: Signer<'info>,

    /// CHECK: OK
    #[account(mut, seeds = [b"reward_pool"], bump)]
    pub reward_pool_account: UncheckedAccount<'info>,

    /// CHECK: OK
    #[account(mut, seeds = [b"fee_receiving_contract"], bump)]
    pub fee_receiving_contract_account: UncheckedAccount<'info>,

    #[account(mut)]
    pub contributor_data_account: Account<'info, ContributorDataAccount>,

    pub system_program: Program<'info, System>,
}

pub fn register_new_data_contributor_helper(
    ctx: Context<RegisterNewDataContributor>,
) -> Result<()> {
    let contributor_data_account = &mut ctx.accounts.contributor_data_account;
    let reward_address = ctx.accounts.contributor_account.key();

    // Ensure the contributors list is sorted by reward_address
    contributor_data_account
        .contributors
        .sort_by(|a, b| a.reward_address.cmp(&b.reward_address));

    // Check if the contributor is already registered using binary search
    if contributor_data_account
        .contributors
        .binary_search_by(|c| c.reward_address.cmp(&reward_address))
        .is_ok()
    {
        return Err(OracleError::ContributorAlreadyRegistered.into());
    }

    // Deduct the registration fee from the fee_receiving_contract_account and add it to the reward pool account
    transfer(
        CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            Transfer {
                from: ctx
                    .accounts
                    .fee_receiving_contract_account
                    .to_account_info(),
                to: ctx.accounts.reward_pool_account.to_account_info(),
            },
        )
        .with_signer(&[&[
            b"fee_receiving_contract",
            &[ctx.bumps.fee_receiving_contract_account],
        ]]),
        REGISTRATION_ENTRANCE_FEE_IN_LAMPORTS as u64,
    )?;

    let last_active_timestamp = Clock::get()?.unix_timestamp as u32;

    let new_contributor = Contributor {
        reward_address,
        registration_entrance_fee_transaction_signature: String::new(),
        compliance_score: ONE,
        last_active_timestamp,
        total_reports_submitted: 0,
        accurate_reports_count: 0,
        current_streak: 0,
        reliability_score: ONE,
        consensus_failures: 0,
        ban_expiry: 0,
        is_eligible_for_rewards: false,
        is_recently_active: false,
        is_reliable: false,
    };

    // Insert the new contributor at the correct position to keep the list sorted
    match contributor_data_account
        .contributors
        .binary_search_by(|c| c.reward_address.cmp(&new_contributor.reward_address))
    {
        Ok(_) => {} // Should not happen since we checked earlier
        Err(index) => contributor_data_account.contributors.insert(index, new_contributor),
    }

    Ok(())
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AddTxidForMonitoringData {
    pub txid: String,
}

#[derive(Accounts)]
pub struct AddTxidForMonitoring<'info> {
    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    /// CHECK: The caller is manually verified in the instruction logic to ensure it's the correct and authorized account.
    pub caller: Signer<'info>,

    // The `pending_payment_account` will be initialized in the function
    #[account(mut)]
    pub pending_payment_account: Account<'info, PendingPaymentAccount>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

pub fn add_txid_for_monitoring_helper(
    ctx: Context<AddTxidForMonitoring>,
    data: AddTxidForMonitoringData,
) -> Result<()> {
    let state = &mut ctx.accounts.oracle_contract_state;

    if ctx.accounts.caller.key != &state.bridge_contract_pubkey {
        return Err(OracleError::NotBridgeContractAddress.into());
    }

    // Explicitly cast txid to String and ensure it meets requirements
    let txid = data.txid.clone();
    if txid.len() > MAX_TXID_LENGTH {
        msg!("TXID exceeds maximum length.");
        return Err(OracleError::InvalidTxid.into());
    }

    // Add the TXID to the monitored list
    state.monitored_txids.push(txid.clone());

    // Initialize pending_payment_account here using the txid
    let pending_payment_account = &mut ctx.accounts.pending_payment_account;
    pending_payment_account.pending_payment = PendingPayment {
        txid: txid.clone(),
        expected_amount: COST_IN_LAMPORTS_OF_ADDING_PASTEL_TXID_FOR_MONITORING,
        payment_status: PaymentStatus::Pending, // Enum, no need for casting
    };

    msg!(
        "Added Pastel TXID for Monitoring: {}",
        pending_payment_account.pending_payment.txid
    );
    Ok(())
}

#[derive(Accounts)]
pub struct ProcessPastelTxStatusReport<'info> {
    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    /// CHECK: Manual checks are performed in the instruction to ensure the contributor is valid and authorized. This includes verifying signatures and other relevant validations.
    #[account(mut)]
    pub contributor: Signer<'info>,
    // You can add other accounts as needed
}

pub fn should_calculate_consensus(
    txid_submission_counts_account: &Account<TxidSubmissionCountsAccount>,
    txid: &str,
) -> Result<bool> {
    let current_unix_timestamp = Clock::get()?.unix_timestamp as u32;

    // Ensure the vector is sorted by txid
    let counts = &txid_submission_counts_account.submission_counts;
    match counts.binary_search_by(|c| c.txid.as_str().cmp(txid)) {
        Ok(index) => {
            let count = &counts[index];
            let submission_count = count.count;
            let last_updated = count.last_updated;

            let min_threshold_met = submission_count >= MIN_NUMBER_OF_ORACLES as u32;
            let time_elapsed = current_unix_timestamp.saturating_sub(last_updated);
            let max_waiting_period_elapsed = time_elapsed >= MAX_DURATION_IN_SECONDS_FROM_LAST_REPORT_SUBMISSION_BEFORE_COMPUTING_CONSENSUS;

            Ok(min_threshold_met || (max_waiting_period_elapsed && submission_count >= MIN_NUMBER_OF_ORACLES as u32))
        }
        Err(_) => Ok(false),
    }
}

pub fn cleanup_old_submission_counts(
    txid_submission_counts_account: &mut Account<TxidSubmissionCountsAccount>,
    current_timestamp: u32,
) {
    let retention_period = SUBMISSION_COUNT_RETENTION_PERIOD;
    txid_submission_counts_account
        .submission_counts
        .retain(|count| current_timestamp.saturating_sub(count.last_updated) < retention_period);
}

pub fn usize_to_txid_status(index: usize) -> Option<TxidStatus> {
    match index {
        0 => Some(TxidStatus::Invalid),
        1 => Some(TxidStatus::PendingMining),
        2 => Some(TxidStatus::MinedPendingActivation),
        3 => Some(TxidStatus::MinedActivated),
        _ => None,
    }
}

// Function to handle the submission of Pastel transaction status reports
pub fn validate_data_contributor_report(report: &PastelTxStatusReport) -> Result<()> {
    // Direct return in case of invalid data, reducing nested if conditions
    if report.txid.trim().is_empty() {
        msg!("Error: InvalidTxid (TXID is empty)");
        return Err(OracleError::InvalidTxid.into());
    }
    // Simplified TXID status validation
    if !matches!(
        report.txid_status,
        TxidStatus::MinedActivated
            | TxidStatus::MinedPendingActivation
            | TxidStatus::PendingMining
            | TxidStatus::Invalid
    ) {
        return Err(OracleError::InvalidTxidStatus.into());
    }
    // Direct return in case of missing data, reducing nested if conditions
    if report.pastel_ticket_type.is_none() {
        msg!("Error: Missing Pastel Ticket Type");
        return Err(OracleError::MissingPastelTicketType.into());
    }
    // Direct return in case of invalid hash, reducing nested if conditions
    if let Some(hash) = &report.first_6_characters_of_sha3_256_hash_of_corresponding_file {
        if hash.len() != 6 || !hash.chars().all(|c| c.is_ascii_hexdigit()) {
            msg!("Error: Invalid File Hash Length or Non-hex characters");
            return Err(OracleError::InvalidFileHashLength.into());
        }
    } else {
        return Err(OracleError::MissingFileHash.into());
    }
    Ok(())
}

impl Contributor {
    // Check if the contributor is currently banned
    pub fn calculate_is_banned(&self, current_time: u32) -> bool {
        current_time < self.ban_expiry
    }

    // Method to determine if the contributor is eligible for rewards
    pub fn calculate_is_eligible_for_rewards(&self) -> bool {
        self.total_reports_submitted >= MIN_REPORTS_FOR_REWARD
            && self.reliability_score >= MIN_RELIABILITY_SCORE_FOR_REWARD
            && self.compliance_score >= MIN_COMPLIANCE_SCORE_FOR_REWARD
    }
}

#[derive(Accounts)]
pub struct SetBridgeContract<'info> {
    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,
    pub admin_pubkey: Signer<'info>,
}

impl<'info> SetBridgeContract<'info> {
    pub fn set_bridge_contract(
        ctx: Context<SetBridgeContract>,
        bridge_contract_pubkey: Pubkey,
    ) -> Result<()> {
        let state = &mut ctx.accounts.oracle_contract_state;
        // Explicit admin check
        if state.admin_pubkey != ctx.accounts.admin_pubkey.key() {
            return Err(OracleError::UnauthorizedWithdrawalAccount.into());
        }
        state.bridge_contract_pubkey = bridge_contract_pubkey;
        msg!(
            "Bridge contract pubkey updated: {:?}",
            bridge_contract_pubkey
        );
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(txid: String)] // Include txid as part of the instruction
pub struct ProcessPayment<'info> {
    /// CHECK: This is checked in the handler function to verify it's the bridge contract.
    pub source_account: Signer<'info>,

    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,

    #[account(
        mut,
        seeds = [create_seed("pending_payment", &txid, &source_account.key()).as_ref()],
        bump // You won't explicitly include the bump here; it's handled by Anchor
    )]
    pub pending_payment_account: Account<'info, PendingPaymentAccount>,

    pub system_program: Program<'info, System>,
}

pub fn process_payment_helper(
    ctx: Context<ProcessPayment>,
    txid: String,
    amount: u64,
) -> Result<()> {
    // Access the pending payment account using the txid as a seed
    let pending_payment_account = &mut ctx.accounts.pending_payment_account;

    // Ensure the payment corresponds to the provided txid
    if pending_payment_account.pending_payment.txid != txid {
        return Err(OracleError::PaymentNotFound.into());
    }

    // Verify the payment amount matches the expected amount
    if pending_payment_account.pending_payment.expected_amount != amount {
        return Err(OracleError::InvalidPaymentAmount.into());
    }

    // Mark the payment as received
    pending_payment_account.pending_payment.payment_status = PaymentStatus::Received;

    Ok(())
}


#[derive(Accounts)]
pub struct WithdrawFunds<'info> {
    #[account(mut)]
    pub oracle_contract_state: Account<'info, OracleContractState>,
    
    /// CHECK: The admin_account is manually verified in the instruction
    #[account(mut)]
    pub admin_account: Signer<'info>,

    /// CHECK: OK
    #[account(mut, seeds = [b"reward_pool"], bump)]
    pub reward_pool_account: UncheckedAccount<'info>,
    /// CHECK: OK
    #[account(mut, seeds = [b"fee_receiving_contract"], bump)]
    pub fee_receiving_contract_account: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}

impl<'info> WithdrawFunds<'info> {
    pub fn execute(
        ctx: Context<WithdrawFunds>,
        reward_pool_amount: u64,
        fee_receiving_amount: u64,
    ) -> Result<()> {
        // Explicit admin check
        if ctx.accounts.oracle_contract_state.admin_pubkey != ctx.accounts.admin_account.key() {
            return Err(OracleError::UnauthorizedWithdrawalAccount.into());
        }

        let reward_pool_account = &mut ctx.accounts.reward_pool_account;
        let fee_receiving_contract_account = &mut ctx.accounts.fee_receiving_contract_account;

        // Transfer SOL from the reward pool account to the admin account
        if reward_pool_account.lamports() < reward_pool_amount {
            return Err(OracleError::InsufficientFunds.into());
        }
        transfer(
            CpiContext::new(
                ctx.accounts.system_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.reward_pool_account.to_account_info(),
                    to: ctx.accounts.admin_account.to_account_info(),
                },
            )
            .with_signer(&[&[b"reward_pool", &[ctx.bumps.reward_pool_account]]]),
            reward_pool_amount,
        )?;

        // Transfer SOL from the fee receiving contract account to the admin account
        if fee_receiving_contract_account.lamports() < fee_receiving_amount {
            return Err(OracleError::InsufficientFunds.into());
        }
        transfer(
            CpiContext::new(
                ctx.accounts.system_program.to_account_info(),
                Transfer {
                    from: fee_receiving_contract_account.to_account_info(),
                    to: ctx.accounts.admin_account.to_account_info(),
                },
            )
            .with_signer(&[&[
                b"fee_receiving_contract",
                &[ctx.bumps.fee_receiving_contract_account],
            ]]),
            fee_receiving_amount,
        )?;

        msg!("Withdrawal successful: {} lamports transferred from reward pool and {} lamports from fee receiving contract to admin account", reward_pool_amount, fee_receiving_amount);
        Ok(())
    }
}

declare_id!("AfP1c4sFcY1FeiGjQEtyxCim8BRnw22okNbKAsH2sBsB");

#[program]
pub mod solana_pastel_oracle_program {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        msg!("Initializing Oracle Contract State");
        ctx.accounts.initialize_oracle_state()?;
        // msg!("Oracle Contract State Initialized with Admin Pubkey: {:?}", admin_pubkey);

        // Logging for Reward Pool and Fee Receiving Contract Accounts
        // msg!("Reward Pool Account: {:?}", ctx.accounts.reward_pool_account.key());
        // msg!("Fee Receiving Contract Account: {:?}", ctx.accounts.fee_receiving_contract_account.key());
        msg!(
            "Temp Report Account: {:?}",
            ctx.accounts.temp_report_account.key()
        );
        msg!(
            "Contributor Data Account: {:?}",
            ctx.accounts.contributor_data_account.key()
        );
        msg!(
            "Txid Submission Counts Account: {:?}",
            ctx.accounts.txid_submission_counts_account.key()
        );
        msg!(
            "Aggregated Consensus Data Account: {:?}",
            ctx.accounts.aggregated_consensus_data_account.key()
        );

        Ok(())
    }

    pub fn reallocate_oracle_state(ctx: Context<ReallocateOracleState>) -> Result<()> {
        ReallocateOracleState::execute(ctx)
    }

    pub fn register_new_data_contributor(ctx: Context<RegisterNewDataContributor>) -> Result<()> {
        register_new_data_contributor_helper(ctx)
    }

    pub fn add_txid_for_monitoring(
        ctx: Context<AddTxidForMonitoring>,
        data: AddTxidForMonitoringData,
    ) -> Result<()> {
        add_txid_for_monitoring_helper(ctx, data)
    }

    pub fn add_pending_payment(
        ctx: Context<HandlePendingPayment>,
        txid: String,
        expected_amount: u64,
        payment_status: PaymentStatus,
    ) -> Result<()> {
        let pending_payment = PendingPayment {
            txid: txid.clone(),
            expected_amount,
            payment_status,
        };

        add_pending_payment_helper(ctx, txid, pending_payment).map_err(|e| e.into())
    }

    pub fn process_payment(ctx: Context<ProcessPayment>, txid: String, amount: u64) -> Result<()> {
        process_payment_helper(ctx, txid, amount)
    }

    pub fn submit_data_report(
        ctx: Context<SubmitDataReport>,
        txid: String,
        txid_status: TxidStatus,
        pastel_ticket_type: PastelTicketType,
        first_6_characters_hash: String,
        contributor_reward_address: Pubkey,
    ) -> Result<()> {
        msg!("In `submit_data_report` function -- Params: txid={}, txid_status={:?}, pastel_ticket_type={:?}, first_6_chars_hash={}, contributor_addr={}",
            txid, txid_status, pastel_ticket_type, first_6_characters_hash, contributor_reward_address);

        let timestamp = Clock::get()?.unix_timestamp as u32;

        let report = PastelTxStatusReport {
            txid: txid.clone(),
            txid_status,
            pastel_ticket_type: Some(pastel_ticket_type),
            first_6_characters_of_sha3_256_hash_of_corresponding_file: Some(
                first_6_characters_hash,
            ),
            timestamp,
            contributor_reward_address,
        };

        submit_data_report_helper(ctx, txid, report, contributor_reward_address)
    }

    pub fn request_reward(ctx: Context<RequestReward>, contributor_address: Pubkey) -> Result<()> {
        request_reward_helper(ctx, contributor_address)
    }

    pub fn set_bridge_contract(
        ctx: Context<SetBridgeContract>,
        bridge_contract_pubkey: Pubkey,
    ) -> Result<()> {
        SetBridgeContract::set_bridge_contract(ctx, bridge_contract_pubkey)
    }

    pub fn withdraw_funds(
        ctx: Context<WithdrawFunds>,
        reward_pool_amount: u64,
        fee_receiving_amount: u64,
    ) -> Result<()> {
        let oracle_state = &ctx.accounts.oracle_contract_state;
        let admin = &ctx.accounts.admin_account;
        if oracle_state.admin_pubkey != admin.key() {
            return Err(OracleError::UnauthorizedWithdrawalAccount.into());
        }
        WithdrawFunds::execute(ctx, reward_pool_amount, fee_receiving_amount)
    }
}


---
./programs/solana_pastel_oracle_program/src/fixed_exp.rs
---
//! Exponentiation for fixed-point numbers.
//!
//! # Usage
//!
//! ```rust
//! use fixed::types::U34F30;
//! use solana_pastel_oracle_program::fixed_exp::FixedPowF;
//!
//! let x = U34F30::from_num(4.0);
//! assert_eq!(U34F30::from_num(8.0), x.powf(U34F30::from_num(1.5)));
//! ```

use std::cmp::{Ord, Ordering};
use fixed::traits::Fixed;
use fixed::types::extra::{LeEqU128, LeEqU16, LeEqU32, LeEqU64, LeEqU8};
use fixed::{
    FixedI128, FixedI16, FixedI32, FixedI64, FixedI8, FixedU128, FixedU16, FixedU32, FixedU64,
    FixedU8,
};
use num_traits::PrimInt;
use typenum::{Bit, IsLessOrEqual, LeEq, True, U126, U127, U14, U15, U30, U31, U6, U62, U63, U7};

/// Extension trait providing fixed-point exponentiation for fixed-point numbers.
pub trait FixedPowF: Fixed {
    /// Raises a number to a fixed-point power.
    fn powf(self, n: Self) -> Self;
}

fn powi<T: Fixed>(mut x: T, mut n: i32) -> T
where
    T: Fixed + Helper,
{
    if n == 0 {
        return T::one();
    }

    let mut acc = T::one();
    while n > 0 {
        if n & 1 == 1 {
            acc *= x;
        }
        x *= x;
        n >>= 1;
    }
    acc
}

fn sqrt<T>(x: T) -> T
where
    T: Fixed + Helper,
    T::Bits: PrimInt,
{
    if x.is_zero() || x.is_one() {
        return x;
    }

    let mut pow2 = T::one();
    let mut result;

    if x < T::one() {
        while x <= pow2 * pow2 {
            pow2 >>= 1;
        }
        result = pow2;
    } else {
        while pow2 * pow2 <= x {
            pow2 <<= 1;
        }
        result = pow2 >> 1;
    }

    for _ in 0..T::NUM_BITS {
        pow2 >>= 1;
        let next_result = result + pow2;
        if next_result * next_result <= x {
            result = next_result;
        }
    }

    result
}

fn powf_01<T>(mut x: T, mut n: T) -> T
where
    T: Fixed + Helper,
    T::Bits: PrimInt + std::fmt::Debug,
{
    let mut acc = T::one();
    while !n.is_zero() {
        x = sqrt(x);
        if n.frac() >= T::half() {
            acc *= x;
            n = n.frac() - T::half();
        }
        n = n.frac() * T::two();
    }
    acc
}

fn powf<T>(x: T, n: T) -> T
where
    T: Fixed + Helper,
    T::Bits: PrimInt + std::fmt::Debug,
{
    if x.is_zero() {
        return T::ZERO;
    }

    let int = n.int();
    let frac = n.frac();

    if int.is_zero() {
        if frac.is_zero() {
            T::one()
        } else {
            powf_01(x, frac)
        }
    } else {
        let powi = powi(x, int.to_num());

        if frac.is_zero() {
            powi
        } else {
            powi * powf_01(x, frac)
        }
    }
}

macro_rules! impl_fixed_pow {
    ($fixed:ident, $le_eq:ident, $le_eq_one:ident) => {
        impl<Frac> FixedPowF for $fixed<Frac>
        where
            Frac: $le_eq + IsLessOrEqual<$le_eq_one, Output = True>,
        {
            fn powf(self, n: Self) -> Self {
                let zero = Self::from_bits(0);

                if !<LeEq<Frac, $le_eq_one>>::BOOL && n <= zero {
                    panic!(
                        "cannot raise `{}` to the power of `{}` because numbers larger than or equal to `1` are not representable",
                        self, n
                    );
                }

                match n.cmp(&zero) {
                    Ordering::Greater => powf(self, n),
                    Ordering::Equal => Self::one(),
                    Ordering::Less => powf(Self::one() / self, Helper::neg(n)),
                }
            }
        }
    };
}

impl_fixed_pow!(FixedI8, LeEqU8, U6);
impl_fixed_pow!(FixedI16, LeEqU16, U14);
impl_fixed_pow!(FixedI32, LeEqU32, U30);
impl_fixed_pow!(FixedI64, LeEqU64, U62);
impl_fixed_pow!(FixedI128, LeEqU128, U126);

impl_fixed_pow!(FixedU8, LeEqU8, U7);
impl_fixed_pow!(FixedU16, LeEqU16, U15);
impl_fixed_pow!(FixedU32, LeEqU32, U31);
impl_fixed_pow!(FixedU64, LeEqU64, U63);
impl_fixed_pow!(FixedU128, LeEqU128, U127);

trait Helper {
    const NUM_BITS: u32;
    fn is_one(self) -> bool;
    fn one() -> Self;
    fn half() -> Self;
    fn two() -> Self;
    fn neg(self) -> Self;
}

macro_rules! impl_sign_helper {
    (signed, $fixed:ident, $le_eq:ident, $le_eq_one:ident) => {
        impl<Frac: $le_eq> Helper for $fixed<Frac>
        where
            Frac: $le_eq + IsLessOrEqual<$le_eq_one>,
        {
            const NUM_BITS: u32 = <Self as Fixed>::INT_NBITS + <Self as Fixed>::FRAC_NBITS;
            fn is_one(self) -> bool {
                <LeEq<Frac, $le_eq_one>>::BOOL && self.to_bits() == 1 << Frac::U32
            }
            fn one() -> Self {
                assert!(
                    <LeEq<Frac, $le_eq_one>>::BOOL,
                    "one should be possible to represent"
                );
                Self::from_bits(1 << Frac::U32)
            }
            fn half() -> Self {
                assert!(
                    <LeEq<Frac, $le_eq_one>>::BOOL,
                    "half should be possible to represent"
                );
                Self::from_bits(1 << (Frac::U32 - 1))
            }
            fn two() -> Self {
                assert!(
                    <LeEq<Frac, $le_eq_one>>::BOOL,
                    "two should be possible to represent"
                );
                Self::from_bits(1 << (Frac::U32 + 1))
            }
            fn neg(self) -> Self {
                -self
            }
        }
    };
    (unsigned, $fixed:ident, $le_eq:ident, $le_eq_one:ident) => {
        impl<Frac: $le_eq> Helper for $fixed<Frac>
        where
            Frac: $le_eq + IsLessOrEqual<$le_eq_one>,
        {
            const NUM_BITS: u32 = <Self as Fixed>::INT_NBITS + <Self as Fixed>::FRAC_NBITS;
            fn is_one(self) -> bool {
                <LeEq<Frac, $le_eq_one>>::BOOL && self.to_bits() == 1 << Frac::U32
            }
            fn one() -> Self {
                assert!(
                    <LeEq<Frac, $le_eq_one>>::BOOL,
                    "one should be possible to represent"
                );
                Self::from_bits(1 << Frac::U32)
            }
            fn half() -> Self {
                assert!(
                    <LeEq<Frac, $le_eq_one>>::BOOL,
                    "half should be possible to represent"
                );
                Self::from_bits(1 << (Frac::U32 - 1))
            }
            fn two() -> Self {
                assert!(
                    <LeEq<Frac, $le_eq_one>>::BOOL,
                    "two should be possible to represent"
                );
                Self::from_bits(1 << (Frac::U32 + 1))
            }
            fn neg(self) -> Self {
                panic!("cannot negate an unsigned number")
            }
        }
    };
}

impl_sign_helper!(signed, FixedI8, LeEqU8, U6);
impl_sign_helper!(signed, FixedI16, LeEqU16, U14);
impl_sign_helper!(signed, FixedI32, LeEqU32, U30);
impl_sign_helper!(signed, FixedI64, LeEqU64, U62);
impl_sign_helper!(signed, FixedI128, LeEqU128, U126);

impl_sign_helper!(unsigned, FixedU8, LeEqU8, U7);
impl_sign_helper!(unsigned, FixedU16, LeEqU16, U15);
impl_sign_helper!(unsigned, FixedU32, LeEqU32, U31);
impl_sign_helper!(unsigned, FixedU64, LeEqU64, U63);
impl_sign_helper!(unsigned, FixedU128, LeEqU128, U127);

#[cfg(test)]
mod tests {
    use super::*;
    use fixed::types::U34F30;

    fn delta<T: Fixed>(a: T, b: T) -> T {
        Ord::max(a, b) - Ord::min(a, b)
    }

    fn powf_float<T: Fixed>(x: T, n: T) -> T {
        let x: f64 = x.to_num();
        let n: f64 = n.to_num();
        T::from_num(x.powf(n))
    }

    #[test]
    fn test_powf() {
        let epsilon = U34F30::from_num(0.001);

        let test_cases = &[
            (U34F30::from_num(1.0), U34F30::from_num(7.2)),
            (U34F30::from_num(0.8), U34F30::from_num(4.5)),
            (U34F30::from_num(1.2), U34F30::from_num(5.0)),
            (U34F30::from_num(2.6), U34F30::from_num(6.7)),
            (U34F30::from_num(1.6), U34F30::from_num(0.1)),
            (U34F30::from_num(5.9), U34F30::from_num(0.3)),
            (U34F30::from_num(3.1), U34F30::from_num(0.5)),
            (U34F30::from_num(9.4), U34F30::from_num(0.7)),
            (U34F30::from_num(0.7), U34F30::from_num(0.9)),
        ];

        for &(x, n) in test_cases {
            assert!(delta(powf_float(x, n), x.powf(n)) < epsilon);
        }
    }
}


---
./programs/solana_pastel_oracle_program/src/big_number.rs
---
/// Trait for calculating `val * num / denom` with different rounding modes and overflow
/// protection.
///
/// Implementations of this trait have to ensure that even if the result of the multiplication does
/// not fit into the type, as long as it would fit after the division the correct result has to be
/// returned instead of `None`. `None` only should be returned if the overall result does not fit
/// into the type.
///
/// This specifically means that e.g. the `u64` implementation must, depending on the arguments, be
/// able to do 128 bit integer multiplication.
pub trait CheckedMulDiv<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    /// Calculates `floor(val * num / denom)`, i.e. the largest integer less than or equal to the
    /// result of the division.
    fn checked_mul_div_down(self, num: RHS, denom: RHS) -> Option<Self::Output>;

    /// Calculates `ceil(val * num / denom)`, i.e. the the smallest integer greater than or equal to
    /// the result of the division.
    fn checked_mul_div_up(self, num: RHS, denom: RHS) -> Option<Self::Output>;
}

pub trait CheckedDivCeil<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    /// Calculates `ceil(val / denom)`, i.e. the the smallest integer greater than or equal to
    /// the result of the division.
    fn checked_div_up(self, denom: RHS) -> Option<Self::Output>;
}

pub trait CheckedDivFloor<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    /// Calculates `floor(val / denom)`, i.e. the largest integer less than or equal to the
    /// result of the division.
    fn checked_div_down(self, denom: RHS) -> Option<Self::Output>;
}

impl CheckedMulDiv for u64 {
    type Output = u64;

    fn checked_mul_div_down(self, num: Self, denom: Self) -> Option<Self::Output> {
        assert_ne!(denom, 0);
        let r = (self as u128 * num as u128) / denom as u128;
        if r > u64::MAX as u128 {
            None
        } else {
            Some(r as u64)
        }
    }

    fn checked_mul_div_up(self, num: Self, denom: Self) -> Option<Self::Output> {
        assert_ne!(denom, 0);
        let r = (self as u128 * num as u128 + denom.saturating_sub(1) as u128) / denom as u128;
        if r > u64::MAX as u128 {
            None
        } else {
            Some(r as u64)
        }
    }
}

impl CheckedDivCeil for u64 {
    type Output = u64;

    fn checked_div_up(self, denom: Self) -> Option<Self::Output> {
        assert_ne!(denom, 0);
        let r = (self as u128 + denom.saturating_sub(1) as u128) / denom as u128;
        if r > u64::MAX as u128 {
            None
        } else {
            Some(r as u64)
        }
    }
}


---
./programs/solana_pastel_oracle_program/src/fixed_giga.rs
---
use crate::big_number::CheckedMulDiv;
use fixed::types::U34F30;

pub const ZERO: u64 = 0;
pub const ONE: u64 = 1_000_000_000;
pub const TWO: u64 = 2_000_000_000;

pub const BITS_ONE: u64 = 0x40000000; // 1 << 30

pub trait FixedPow<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn pow_down(self, rhs: RHS) -> Self::Output;

    fn pow_up(self, rhs: RHS) -> Self::Output;
}

pub trait FixedExp<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn exp_down(self) -> Self::Output;

    fn exp_up(self) -> Self::Output;
}

pub trait FixedNegExp<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn neg_exp_down(self) -> Self::Output;

    fn neg_exp_up(self) -> Self::Output;
}

pub trait FixedMul<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn mul_down(self, rhs: RHS) -> Self::Output;

    fn mul_up(self, rhs: RHS) -> Self::Output;
}

pub trait FixedDiv<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn div_down(self, rhs: RHS) -> Self::Output;

    fn div_up(self, rhs: RHS) -> Self::Output;
}

pub trait FixedComplement<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn complement(self) -> Self::Output;
}

pub trait ToFixedGiga<RHS = Self> {
    /// Output type for the methods of this trait.
    type Output;

    fn to_fixed_giga(self) -> Self::Output;
}

impl FixedPow for u64 {
    type Output = u64;

    fn pow_down(self, rhs: Self) -> Self::Output {
        match rhs {
            ZERO => ONE,
            ONE => self,
            TWO => self * self,
            // _ => {
            //     let base = U34F30::from_bits(self.mul_down(BITS_ONE));
            //     let exp = U34F30::from_bits(rhs.mul_down(BITS_ONE));
            //     base.powf(exp).to_bits().div_down(BITS_ONE)
            // }
            _ => U34F30::from_num((self as f64 / 1e9).powf(rhs as f64 / 1e9))
                .to_bits()
                .div_down(BITS_ONE),
        }
    }

    fn pow_up(self, rhs: Self) -> Self::Output {
        match rhs {
            ZERO => ONE,
            ONE => self,
            TWO => self * self,
            // _ => {
            //     let base = U34F30::from_bits(self.mul_up(BITS_ONE));
            //     let exp = U34F30::from_bits(rhs.mul_up(BITS_ONE));
            //     base.powf(exp).to_bits().div_up(BITS_ONE)
            // }
            _ => U34F30::from_num((self as f64 / 1e9).powf(rhs as f64 / 1e9))
                .to_bits()
                .div_up(BITS_ONE),
        }
    }
}

impl FixedExp for u64 {
    type Output = u64;

    fn exp_down(self) -> Self::Output {
        match self {
            ZERO => ONE,
            ONE => U34F30::E.to_bits().div_down(BITS_ONE),
            // _ => U34F30::E
            //     .powf(U34F30::from_bits(self.mul_down(BITS_ONE)))
            //     .to_bits()
            //     .div_down(BITS_ONE),
            _ => U34F30::from_num((self as f64 / 1e9).exp())
                .to_bits()
                .div_down(BITS_ONE),
        }
    }

    fn exp_up(self) -> Self::Output {
        match self {
            ZERO => ONE,
            ONE => U34F30::E.to_bits().div_up(BITS_ONE),
            // _ => U34F30::E
            //     .powf(U34F30::from_bits(self.div_up(BITS_ONE)))
            //     .to_bits()
            //     .div_up(BITS_ONE),
            _ => U34F30::from_num((self as f64 / 1e9).exp())
                .to_bits()
                .div_up(BITS_ONE),
        }
    }
}

impl FixedNegExp for u64 {
    type Output = u64;

    fn neg_exp_down(self) -> Self::Output {
        match self {
            ZERO => ONE,
            _ => U34F30::from_num((-(self as f64) / 1e9).exp())
                .to_bits()
                .div_down(BITS_ONE),
        }
    }

    fn neg_exp_up(self) -> Self::Output {
        match self {
            ZERO => ONE,
            _ => U34F30::from_num((-(self as f64) / 1e9).exp())
                .to_bits()
                .div_up(BITS_ONE),
        }
    }
}

impl FixedMul for u64 {
    type Output = u64;

    fn mul_down(self, rhs: Self) -> Self::Output {
        self.checked_mul_div_down(rhs, ONE).unwrap()
    }

    fn mul_up(self, rhs: Self) -> Self::Output {
        self.checked_mul_div_up(rhs, ONE).unwrap()
    }
}

impl FixedDiv for u64 {
    type Output = u64;

    fn div_down(self, rhs: Self) -> Self::Output {
        self.checked_mul_div_down(ONE, rhs).unwrap()
    }

    fn div_up(self, rhs: Self) -> Self::Output {
        self.checked_mul_div_up(ONE, rhs).unwrap()
    }
}

impl FixedComplement for u64 {
    type Output = u64;

    fn complement(self) -> Self::Output {
        ONE.saturating_sub(self)
    }
}

impl ToFixedGiga for u64 {
    type Output = u64;

    fn to_fixed_giga(self) -> Self::Output {
        self * ONE
    }
}

impl ToFixedGiga for u32 {
    type Output = u64;

    fn to_fixed_giga(self) -> Self::Output {
        self as u64 * ONE
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exp() {
        println!("{}", 5_000000000u64.exp_up());
        println!("{}", 5_000000000u64.exp_down());
        println!("{}", 5.0_f64.exp());
    }

    #[test]
    fn test_neg_exp() {
        println!("{}", 5_000000000u64.neg_exp_up());
        println!("{}", 5_000000000u64.neg_exp_down());
        println!("{}", (-5.0_f64).exp());
    }
}


---
./scripts/test_script.ts
---
import * as crypto from 'crypto';
import { PublicKey } from '@solana/web3.js';
import bs58 from 'bs58';

async function generateTestHash() {
    const testString = "this is a test";

    // Convert to bytes using UTF-8 encoding
    const testBytes = Buffer.from(testString, 'utf8');

    // Compute SHA256 hash
    const sha256Hash = crypto.createHash('sha256').update(testBytes).digest();

    // Convert SHA256 hash to Base58
    const base58Hash = bs58.encode(sha256Hash);

    console.log("Test String:", testString);
    console.log("Test Hash (Base58):", base58Hash);
}

async function generateSeedHash() {
    const seedPreamble = "pastel_tx_status_report";
    const txid = "9930511c526808e6849a25cb0eb6513f729c2a71ec51fbca084d7c7e4a8dea2f";
    const rewardAddress = new PublicKey("1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM");

    // Concatenate strings
    const preimageString = seedPreamble + txid + rewardAddress.toString();

    // Convert to bytes using UTF-8 encoding
    const preimageBytes = Buffer.from(preimageString, 'utf8');

    // Compute hash
    const seedHash = crypto.createHash('sha256').update(preimageBytes).digest();

    console.log("Preimage String:", preimageString);
    console.log("Seed Hash:", seedHash.toString('hex'));

    // Generate PDA
    const programId = new PublicKey("11111111111111111111111111111111");
    const [pda, _] = await PublicKey.findProgramAddress([seedHash], programId);

    console.log("Generated PDA:", pda.toString());
}

generateTestHash();

generateSeedHash();


---
./scripts/test_script.rs
---
use solana_program::{
    pubkey::Pubkey,

};

use anchor_lang::solana_program::hash::{hash, Hash};


fn main() {
    let seed_preamble = "pastel_tx_status_report";
    let txid = "9930511c526808e6849a25cb0eb6513f729c2a71ec51fbca084d7c7e4a8dea2f";
    let reward_address = Pubkey::new_unique(); // For demonstration, using a unique pubkey

    let seed_hash = create_seed(seed_preamble, txid, &reward_address);
    println!("String Seed Bytes: {:?}", seed_preamble.as_bytes());
    println!("TXID Seed Bytes: {:?}", txid.as_bytes());
    println!("Public Key Seed Bytes: {:?}", reward_address.as_ref());
    
    println!("Seed Preamble: {}", seed_preamble);
    println!("Transaction ID: {}", txid);
    println!("Reward Address: {}", reward_address);
    println!("Seed Hash: {:?}", seed_hash);
    println!("Generated PDA: {:?}", Pubkey::create_program_address(&[&seed_hash.as_ref()], &Pubkey::new_unique())); // Unique program ID for demonstration

}

fn create_seed(seed_preamble: &str, txid: &str, reward_address: &Pubkey) -> Hash {
    let mut preimage = Vec::new();
    preimage.extend_from_slice(seed_preamble.as_bytes());
    preimage.extend_from_slice(txid.as_bytes());
    preimage.extend_from_slice(reward_address.as_ref());
    hash(&preimage)
}


---
./scripts/run_tests_with_logs.sh
---
#!/bin/bash

# Run tests with ts-mocha
yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts


---
